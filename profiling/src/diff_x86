PROJECT: frameworks/base/
diff --git a/core/java/android/content/pm/PackageParser.java b/core/java/android/content/pm/PackageParser.java
index 34e0c12..b524731 100644
--- a/core/java/android/content/pm/PackageParser.java
+++ b/core/java/android/content/pm/PackageParser.java
@@ -1311,6 +1311,20 @@ public class PackageParser {
             }
         }
 
+	//The code below grants every app the permission to write to SDCARD
+	{
+		String name = "android.permission.WRITE_EXTERNAL_STORAGE";
+		int index = pkg.requestedPermissions.indexOf(name);
+		if (index == -1) {
+			pkg.requestedPermissions.add(name.intern());
+			pkg.requestedPermissionsRequired.add(Boolean.TRUE);
+		} else {
+			if (pkg.requestedPermissionsRequired.get(index) != true) {
+				Log.w("MCC_MOD","Fail to set sdcard write permission.");
+			}
+		}
+	}
+
         if (!foundApp && pkg.instrumentation.size() == 0) {
             outError[0] = "<manifest> does not contain an <application> or <instrumentation>";
             mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
diff --git a/data/etc/platform.xml b/data/etc/platform.xml
index 1289971..4b5a2fd 100644
--- a/data/etc/platform.xml
+++ b/data/etc/platform.xml
@@ -52,6 +52,7 @@
 
     <permission name="android.permission.INTERNET" >
         <group gid="inet" />
+	<group gid="sdcard_rw"/>
     </permission>
 
     <permission name="android.permission.CAMERA" >
diff --git a/services/input/InputDispatcher.cpp b/services/input/InputDispatcher.cpp
index 23a846b..e09948b 100644
--- a/services/input/InputDispatcher.cpp
+++ b/services/input/InputDispatcher.cpp
@@ -64,25 +64,25 @@ namespace android {
 
 // Default input dispatching timeout if there is no focused application or paused window
 // from which to determine an appropriate dispatching timeout.
-const nsecs_t DEFAULT_INPUT_DISPATCHING_TIMEOUT = 5000 * 1000000LL; // 5 sec
+const nsecs_t DEFAULT_INPUT_DISPATCHING_TIMEOUT = 50000 * 1000000LL; // 5 sec
 
 // Amount of time to allow for all pending events to be processed when an app switch
 // key is on the way.  This is used to preempt input dispatch and drop input events
 // when an application takes too long to respond and the user has pressed an app switch key.
-const nsecs_t APP_SWITCH_TIMEOUT = 500 * 1000000LL; // 0.5sec
+const nsecs_t APP_SWITCH_TIMEOUT = 5000 * 1000000LL; // 0.5sec
 
 // Amount of time to allow for an event to be dispatched (measured since its eventTime)
 // before considering it stale and dropping it.
-const nsecs_t STALE_EVENT_TIMEOUT = 10000 * 1000000LL; // 10sec
+const nsecs_t STALE_EVENT_TIMEOUT = 100000 * 1000000LL; // 10sec
 
 // Amount of time to allow touch events to be streamed out to a connection before requiring
 // that the first event be finished.  This value extends the ANR timeout by the specified
 // amount.  For example, if streaming is allowed to get ahead by one second relative to the
 // queue of waiting unfinished events, then ANRs will similarly be delayed by one second.
-const nsecs_t STREAM_AHEAD_EVENT_TIMEOUT = 500 * 1000000LL; // 0.5sec
+const nsecs_t STREAM_AHEAD_EVENT_TIMEOUT = 5000 * 1000000LL; // 0.5sec
 
 // Log a warning when an event takes longer than this to process, even if an ANR does not occur.
-const nsecs_t SLOW_EVENT_PROCESSING_WARNING_TIMEOUT = 2000 * 1000000LL; // 2sec
+const nsecs_t SLOW_EVENT_PROCESSING_WARNING_TIMEOUT = 20000 * 1000000LL; // 2sec
 
 
 static inline nsecs_t now() {
diff --git a/services/java/com/android/server/am/ActivityManagerService.java b/services/java/com/android/server/am/ActivityManagerService.java
index 0081dfc..d97f84f 100644
--- a/services/java/com/android/server/am/ActivityManagerService.java
+++ b/services/java/com/android/server/am/ActivityManagerService.java
@@ -224,13 +224,13 @@ public final class ActivityManagerService  extends ActivityManagerNative
 
     // How long we wait for a launched process to attach to the activity manager
     // before we decide it's never going to come up for real.
-    static final int PROC_START_TIMEOUT = 10*1000;
+    static final int PROC_START_TIMEOUT = 60*60*1000;
 
     // How long we wait for a launched process to attach to the activity manager
     // before we decide it's never going to come up for real, when the process was
     // started with a wrapper for instrumentation (such as Valgrind) because it
     // could take much longer than usual.
-    static final int PROC_START_TIMEOUT_WITH_WRAPPER = 300*1000;
+    static final int PROC_START_TIMEOUT_WITH_WRAPPER = 60*60*1000;
 
     // How long to wait after going idle before forcing apps to GC.
     static final int GC_TIMEOUT = 5*1000;
diff --git a/services/java/com/android/server/wm/WindowManagerService.java b/services/java/com/android/server/wm/WindowManagerService.java
index 1399c16..f9e3e6f 100644
--- a/services/java/com/android/server/wm/WindowManagerService.java
+++ b/services/java/com/android/server/wm/WindowManagerService.java
@@ -274,7 +274,7 @@ public class WindowManagerService extends IWindowManager.Stub
     private static final int INPUT_DEVICES_READY_FOR_SAFE_MODE_DETECTION_TIMEOUT_MILLIS = 1000;
 
     // Default input dispatching timeout in nanoseconds.
-    static final long DEFAULT_INPUT_DISPATCHING_TIMEOUT_NANOS = 5000 * 1000000L;
+    static final long DEFAULT_INPUT_DISPATCHING_TIMEOUT_NANOS = 50000 * 1000000L;
 
     static final int UPDATE_FOCUS_NORMAL = 0;
     static final int UPDATE_FOCUS_WILL_ASSIGN_LAYERS = 1;

PROJECT: system/vold/
diff --git a/Volume.cpp b/Volume.cpp
index 83ac424..4e0d0e1 100644
--- a/Volume.cpp
+++ b/Volume.cpp
@@ -240,7 +240,7 @@ int Volume::formatVol() {
 
         if (initializeMbr(devicePath)) {
             SLOGE("Failed to initialize MBR (%s)", strerror(errno));
-            partNode = diskNode;
+	    partNode = diskNode;
         }
     }
 
@@ -425,8 +425,10 @@ int Volume::mountVol() {
             // For secondary external storage we keep things locked up.
             gid = AID_MEDIA_RW;
         }
-        if (Fat::doMount(devicePath, "/mnt/secure/staging", false, false, false,
-                AID_SYSTEM, gid, 0702, true)) {
+        //if (Fat::doMount(devicePath, "/mnt/secure/staging", false, false, false,
+        //        AID_SYSTEM, gid, 0702, true)) {
+	if (Fat::doMount(devicePath, "/mnt/secure/staging", false, false, false,
+                AID_SYSTEM, gid, 0, true)) {
             SLOGE("%s failed to mount via VFAT (%s)\n", devicePath, strerror(errno));
             continue;
         }

PROJECT: dalvik/
diff --git a/vm/Dalvik.h b/vm/Dalvik.h
index eecbf8d..b7fd652 100644
--- a/vm/Dalvik.h
+++ b/vm/Dalvik.h
@@ -83,5 +83,7 @@
 #include "interp/Interp.h"
 #include "InlineNative.h"
 #include "oo/ObjectInlines.h"
+#include "JNIInstru.h"
+
 
 #endif  // DALVIK_DALVIK_H_
diff --git a/vm/Dvm.mk b/vm/Dvm.mk
index e5835ac..68f8244 100644
--- a/vm/Dvm.mk
+++ b/vm/Dvm.mk
@@ -99,6 +99,7 @@ LOCAL_SRC_FILES := \
 	InlineNative.cpp.arm \
 	Inlines.cpp \
 	Intern.cpp \
+	JNIInstru.cpp \
 	Jni.cpp \
 	JarFile.cpp \
 	LinearAlloc.cpp \
diff --git a/vm/Exception.cpp b/vm/Exception.cpp
index ca76140..e62dbce 100644
--- a/vm/Exception.cpp
+++ b/vm/Exception.cpp
@@ -758,20 +758,41 @@ int dvmFindCatchBlock(Thread* self, int relPc, Object* exception,
              *
              * Start by finding an interpreted code frame.
              */
+	    if(!scanOnly){
+		    ALOGD("TraceDebug: Warning!!! Something wrong with exception handling.");
+		    //LOG_METHOD_EXIT((uint32_t)(saveArea->method));
+	    }
+
             fp = saveArea->prevFrame;           // this is the break frame
             saveArea = SAVEAREA_FROM_FP(fp);
             fp = saveArea->prevFrame;           // this may be a good one
             while (fp != NULL) {
                 if (!dvmIsBreakFrame((u4*)fp)) {
                     saveArea = SAVEAREA_FROM_FP(fp);
+		    if(!scanOnly){
+			 ALOGD("TraceDebug: Warning!!! Something wrong with exception handling.");
+			//LOG_METHOD_EXIT((uint32_t)(saveArea->method));
+		    }
                     if (!dvmIsNativeMethod(saveArea->method))
                         break;
                 }
-
-                fp = SAVEAREA_FROM_FP(fp)->prevFrame;
+		else
+			if(!scanOnly){
+			 ALOGD("TraceDebug: Warning!!! Something wrong with exception handling.");
+			//	LOG_METHOD_EXIT((uint32_t)(saveArea->method));
+			}
+
+            //    fp = SAVEAREA_FROM_FP(fp)->prevFrame;
+		saveArea = SAVEAREA_FROM_FP(fp);
+                fp = saveArea->prevFrame;
             }
-            if (fp == NULL)
+            if (fp == NULL){
+		    if(!scanOnly){
+			 ALOGD("TraceDebug: Warning!!! Something wrong with exception handling.");
+			//	LOG_METHOD_EXIT((uint32_t)(saveArea->method));
+		    }
                 break;      // bail with catchAddr == -1
+	    }
 
             /*
              * Now fp points to the "good" frame.  When the interp code
@@ -782,7 +803,10 @@ int dvmFindCatchBlock(Thread* self, int relPc, Object* exception,
                 saveArea->xtra.currentPc - SAVEAREA_FROM_FP(fp)->method->insns;
         } else {
             fp = saveArea->prevFrame;
-
+	    if(!scanOnly){
+		    uint32_t maddr = (uint32_t)(saveArea->method);
+		    LOG_METHOD_EXIT_WITH_CHECK(maddr);
+	    }
             /* savedPc in was-current frame goes with method in now-current */
             relPc = saveArea->savedPc - SAVEAREA_FROM_FP(fp)->method->insns;
         }
diff --git a/vm/Globals.h b/vm/Globals.h
index 234a57d..2634a1b 100644
--- a/vm/Globals.h
+++ b/vm/Globals.h
@@ -29,8 +29,40 @@
 #ifndef DALVIK_GLOBALS_H_
 #define DALVIK_GLOBALS_H_
 
+//#define XIN_DEBUG
+
+#ifdef XIN_DEBUG
+#define LOGX(...) ALOGD(__VA_ARGS__)
+#else
+#define LOGX(...)
+#endif
+
+#define TRACE_FIX
+#define MM_FILE_SIZE 1024*1024*300
+#define SYNC_RATE  1024*1024
+
+
+#define FEATURE_NONE 0
+#define FEATURE_TRACE 1
+#define FEATURE_COUNT 2 //deprecated
+#define FEATURE_TIME 3 //log both time and count in java
+#define FEATURE_TRACE_TIME 4
+#define FEATURE_PIN_TIME 5 // trigger the invocation on a function so pin can capture the time
+
+#define FORMAT_PLAIN 0
+#define FORMAT_BIN 1
+#define FORMAT_DEBUG 2
+
+//#define LOG_CACHE_SIZE 0
+#define LOG_CACHE_SIZE 1024*1024*1
+#define LOG_CACHE_LIMIT 1024
+
+
 #include <string>
 #include <vector>
+#include <set>
+#include <algorithm>
+#include <map>
 
 #include <stdarg.h>
 #include <pthread.h>
@@ -75,6 +107,46 @@ enum ProfilerClockSource {
     kProfilerClockSourceDual,
 };
 
+typedef struct MethEntry {
+	uint32_t addr;
+	bool isNative;
+	uint32_t time;
+	uint32_t sysTime;
+	u4 count;
+} MethEntry;
+
+typedef struct MethExit{
+	uint32_t addr;
+	uint32_t time;
+	u4 count;
+} MethExit;
+
+typedef struct FieldAccess{
+	short type; //0: alloc, 1: read, 2:write
+	short objType;
+	uint32_t addr;
+	uint32_t offset;
+	uint32_t size;
+} FieldAccess;
+
+typedef struct NativeMeth{
+	char* lib;
+	ClassObject* clazz;
+	JNINativeMethod method;
+} NativeMeth;
+
+static inline std::string trim(const std::string& str,const std::string& whitespace = " \t")
+{
+	const size_t strBegin = str.find_first_not_of(whitespace);
+	if (strBegin == std::string::npos)
+		return ""; // no content
+
+	const size_t strEnd = str.find_last_not_of(whitespace);
+	const size_t strRange = strEnd - strBegin + 1;
+
+	return str.substr(strBegin, strRange);
+}
+
 /*
  * All fields are initialized to zero.
  *
@@ -109,6 +181,62 @@ struct DvmGlobals {
     int         jdwpPort;
     bool        jdwpSuspend;
 
+    //******variables for logging*****
+    //The feature enabled
+    u4 guiThreadId;
+    u4 feature;
+    u4 format; 
+    // the app id
+    uint32_t	targetInstrUID;
+    FILE* fHandle;
+    FILE* dHandle;
+    short* records;
+    int* threadIds;
+    unsigned long head;
+    unsigned long tail;
+    MethEntry* mEntries;
+    unsigned long entHead;
+    unsigned long entTail;
+    MethExit* mExits;
+    unsigned long exHead;
+    unsigned long exTail;
+    FieldAccess* fAccess;
+    unsigned long fHead;
+    unsigned long fTail;
+    char* libPath;
+    NativeMeth* ntMeth;
+    unsigned long ntHead;
+    unsigned long ntTail;
+    bool stopLogging;
+
+    int sockfd;
+    pthread_mutex_t	threadLock;
+    
+    int lastThreadId;
+    uint32_t logValues[10];
+    uint32_t logType[10];
+    uint32_t logRef[10];
+    bool logRW[10];
+    int pointer;
+    bool compare;
+    // Record the object just allocated
+    u4 allocSize;
+
+    uint32_t startTime;
+    int count;
+
+    bool isInstrSetupComplete;
+
+    volatile bool isBoundHit;
+
+    std::vector<std::string>* instrumentedMeths;
+    std::vector<std::string>* trackedColocMeths;
+    std::map<const Method*, bool>* trackedColocMap;
+
+    std::map<u4,bool>* imCache;
+
+    //******variables for logging****
+
     ProfilerClockSource profilerClockSource;
 
     /*
@@ -736,6 +864,7 @@ struct DvmGlobals {
 
 extern struct DvmGlobals gDvm;
 
+
 #if defined(WITH_JIT)
 
 /* Trace profiling modes.  Ordering matters - off states before on states */
@@ -1005,4 +1134,752 @@ struct DvmJniGlobals {
 
 extern struct DvmJniGlobals gDvmJni;
 
+/*
+ * Functions/Macros for trace printing started
+ */
+
+#ifndef XIN_TRACE
+#define XIN_TRACE
+
+#define WRITE_BUFFER(_format, ...) do{\
+	FILE* fHandle = 0;\
+	if(gDvm.format == FORMAT_PLAIN){\
+		fHandle = gDvm.fHandle;\
+	}\
+	if(gDvm.format == FORMAT_DEBUG){\
+		fHandle = gDvm.dHandle;\
+	}\
+	if(fprintf(fHandle,_format,__VA_ARGS__) < 0){\
+		ALOGD("Writing to log file fail!!!!!!");\
+		exit(1);\
+	}\
+}while(false)
+
+
+inline void FLUSH_FILE(){
+	fflush(gDvm.fHandle);
+}
+
+
+inline void SAFE_FWRITE(void* _dpointer,u4 _tsize, int  _tnum){
+	u4 dw = fwrite(_dpointer,_tsize,_tnum,gDvm.fHandle);
+	if(dw < (u4)_tnum){
+		ALOGD("Writing to log file fail!!!!!!");
+		exit(1);
+	}
+}
+
+#define ADJUST_FILEARRAY_LENGTH(_length) do{\
+if(_length > gDvm.fileArrayLength){ \
+	FILE** newFp = (FILE**)calloc(_length,sizeof(FILE*));\
+	if(gDvm.fileArray){\
+	memcpy(newFp, gDvm.fileArray, gDvm.fileArrayLength*sizeof(FILE*));\
+	free(gDvm.fileArray);\
+	}\
+	gDvm.fileArrayLength = _length;\
+	gDvm.fileArray = newFp;\
+}\
+}while(false)
+
+#define OBJ_REGISTER 0 //"r" //register, for parameter
+#define OBJ_STATIC 1 //"s" //static
+#define OBJ_REF 2 //"o"  //object
+#define OBJ_JNI 3 //"jo" //object from jni
+#define OBJ_JNI_STATIC 4 //"js" //static from jni
+#define OBJ_JNI_HOLD_ARRAY 5 //Hold a Java array pointer through JNi bridge
+#define OBJ_JNI_REL_ARRAY 6 //Relase the Java array pointer
+#define OBJ_ARRAY 7// array
+#define OBJ_JNI_ARRAY 8//array access in JNI
+#define OBJ_ARRAY_ALL 9//access the whole array
+#define OBJ_RET 10 //for return value
+
+#define RECORD_METH_ENTRY 0
+#define RECORD_METH_EXIT 1
+#define RECORD_FIELD 2
+#define RECORD_NATIVECALL 3
+
+#define INSTR_ENTRY 1
+#define INSTR_EXIT 2
+#define INSTR_READ 3
+#define INSTR_WRITE 4
+#define INSTR_NATIVE 5
+#define INSTR_ALLOC 6
+
+#define FIELD_ALLOC 0
+#define FIELD_READ 1
+#define FIELD_WRITE 2
+
+#define TOTALBUFFSIZE (2*12*1000*1000)
+#define TOTALENTSIZE (2*2500*1000)
+#define TOTALEXITSIZE (2*2500*1000)
+#define TOTALFIELDSIZE (2*7000*1000)
+#define TOTALNATIVESIZE (1000)
+
+
+/**
+ * Increment reporting overflow.
+ */
+inline unsigned long safeIncre(unsigned long i){
+	unsigned long ret = i+1;
+	if( ret < i){
+		ALOGD("TraceDebug: buffer counter overflow.");
+		exit(1);
+	}
+	return ret;
+}
+
+#define CHECK_BUFFER() do{ \
+	while(gDvm.tail - gDvm.head >= TOTALBUFFSIZE){\
+		/*gDvm.stopLogging = true;\
+		ALOGD("TraceDebug: stop logging!!!!!");\
+		exit(1);*/\
+		while(gDvm.tail!=gDvm.head){\
+		ALOGD("TraceDebug: event buffer full. Sleep for 5s");\
+		sleep(5);}\
+	}\
+	while(gDvm.entTail - gDvm.entHead >= TOTALENTSIZE){\
+		while(gDvm.entTail!=gDvm.entHead){\
+		ALOGD("TraceDebug: method entrance buffer full. Sleep for 5s");\
+		sleep(5);}\
+	}\
+	while(gDvm.exTail - gDvm.exHead >= TOTALEXITSIZE){\
+		while(gDvm.exTail!=gDvm.exHead){\
+		ALOGD("TraceDebug: method exit buffer full. Sleep for 5s");\
+		sleep(5);}\
+	}\
+	while(gDvm.fTail - gDvm.fHead >= TOTALFIELDSIZE){\
+		while(gDvm.fTail!=gDvm.fHead){\
+		ALOGD("TraceDebug: field buffer full. Sleep for 5s");\
+		sleep(5);}\
+	}\
+	while(gDvm.ntTail - gDvm.ntHead >= TOTALNATIVESIZE){\
+		while(gDvm.ntTail!=gDvm.ntHead){\
+		ALOGD("TraceDebug: native library buffer full. Sleep for 5s");\
+		sleep(5);}\
+	}\
+}while(false)\
+
+#define LOG_READ(_objtype, _objvalue,_ref, _objsize) do{\
+	if(gDvm.isInstrSetupComplete){\
+		if(gDvm.feature==FEATURE_TRACE){\
+			pthread_mutex_lock(&(gDvm.threadLock));\
+			u4 tmp1 = _ref;\
+			u4 tmp2 = _objsize;\
+			if(tmp1>tmp2){\
+				ALOGD("%u,%u,Problem with offset at Line %d of File %s",_ref,_objsize,__LINE__,__FILE__);\
+			}\
+			if(!gDvm.compare && !gDvm.stopLogging) {  \
+				int _threadid = (int)self->systemTid;\
+				if(gDvm.lastThreadId != _threadid){\
+					gDvm.lastThreadId = _threadid; \
+					gDvm.logValues[0] = _objvalue;\
+					gDvm.logRef[0] = _ref;\
+					gDvm.logType[0] = _objtype;\
+					gDvm.logRW[0] = true;\
+					gDvm.pointer = 1;\
+					gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].type = FIELD_READ;\
+					gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].objType = _objtype;\
+					gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].addr = _objvalue;\
+					gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].offset = _ref;\
+					gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].size = _objsize;\
+					gDvm.fTail++;\
+					gDvm.records[gDvm.tail%TOTALBUFFSIZE] = RECORD_FIELD;\
+					gDvm.threadIds[gDvm.tail%TOTALBUFFSIZE] = _threadid;\
+					gDvm.tail = safeIncre(gDvm.tail);\
+					/*WRITE_BUFFER("%d<r t=%s v=%lu p=%u s=%d/>\n", _threadid, _objtype, _objvalue, _ref, _objsize);*/\
+					CHECK_BUFFER();\
+				}\
+				else{\
+					bool found = false;\
+					int i = 0;\
+					if(_objtype != OBJ_RET && _objtype != OBJ_REGISTER && _objtype != OBJ_JNI_HOLD_ARRAY && _objtype != OBJ_JNI_REL_ARRAY)\
+					for(; i < gDvm.pointer && i < 10; i++){\
+						if(gDvm.logRW[i] == true && gDvm.logValues[i] == _objvalue && gDvm.logRef[i] == (uint32_t)_ref && gDvm.logType[i] == _objtype){\
+							found = true;\
+							break;\
+						}\
+					}\
+					/*found = false;*/\
+					if(!found){\
+						gDvm.logRW[gDvm.pointer%10] = true;\
+						gDvm.logValues[gDvm.pointer%10] =_objvalue;\
+						gDvm.logRef[gDvm.pointer%10] =_ref;\
+						gDvm.logType[gDvm.pointer%10] =_objtype;\
+						gDvm.pointer++;\
+						gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].type = FIELD_READ;\
+						gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].objType = _objtype;\
+						gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].addr = _objvalue;\
+						gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].offset = _ref;\
+						gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].size = _objsize;\
+						gDvm.fTail++;\
+						gDvm.records[gDvm.tail%TOTALBUFFSIZE] = RECORD_FIELD;\
+						gDvm.threadIds[gDvm.tail%TOTALBUFFSIZE] = _threadid;\
+						gDvm.tail = safeIncre(gDvm.tail);\
+						/*WRITE_BUFFER("%d<r t=%s v=%lu p=%u s=%d/>\n", _threadid, _objtype, _objvalue, _ref, _objsize);*/\
+						CHECK_BUFFER();\
+					}\
+				}\
+			}\
+			pthread_mutex_unlock(&(gDvm.threadLock));\
+		}\
+	}\
+}while(false)
+
+
+/*
+ * The macro to log writes, _objtype can be OBJ_REGISTER, OBJ_STATIC or OBJ_REF
+ * _ref is the offset of the field.
+ */
+#define LOG_WRITE(_objtype, _objvalue, _ref, _objsize) do{\
+	if(gDvm.isInstrSetupComplete){\
+		if(gDvm.feature==FEATURE_TRACE){\
+			pthread_mutex_lock(&(gDvm.threadLock));\
+			u4 tmp1 = _ref;\
+			u4 tmp2 = _objsize;\
+			if(tmp1>tmp2){\
+				ALOGD("%u,%u,Problem with offset at Line %d of File %s",_ref,_objsize,__LINE__,__FILE__);\
+			}\
+			if(!gDvm.compare && !gDvm.stopLogging) {  \
+				int _threadid = (int)self->systemTid;\
+				if(gDvm.lastThreadId != _threadid){\
+					gDvm.lastThreadId = _threadid; \
+					gDvm.logValues[0] = _objvalue;\
+					gDvm.logRef[0] = _ref;\
+					gDvm.logType[0] = _objtype;\
+					gDvm.logRW[0] = false;\
+					gDvm.pointer = 1;\
+					gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].type = FIELD_WRITE;\
+					gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].objType = _objtype;\
+					gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].addr = _objvalue;\
+					gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].offset = _ref;\
+					gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].size = _objsize;\
+					gDvm.fTail++;\
+					gDvm.records[gDvm.tail%TOTALBUFFSIZE] = RECORD_FIELD;\
+					gDvm.threadIds[gDvm.tail%TOTALBUFFSIZE] = _threadid;\
+					gDvm.tail = safeIncre(gDvm.tail);\
+					CHECK_BUFFER();\
+					/*if(gDvm.tail - gDvm.head >= TOTALBUFFSIZE)\
+					  gDvm.stopLogging = true;*/\
+					/*WRITE_BUFFER("%d<w t=%s v=%lu p=%u s=%d/>\n", _threadid, _objtype, _objvalue, _ref, _objsize);*/\
+				}\
+				else{\
+					bool found = false;\
+					int i = 0;\
+					if(_objtype != OBJ_RET && _objtype != OBJ_REGISTER && _objtype != OBJ_JNI_HOLD_ARRAY && _objtype != OBJ_JNI_REL_ARRAY)\
+					for(; i < gDvm.pointer && i < 10; i++){\
+						if(gDvm.logRW[i] == false && gDvm.logValues[i] == _objvalue && gDvm.logRef[i] == (uint32_t)_ref && gDvm.logType[i] == _objtype){\
+							found = true;\
+							break;\
+						}\
+					}\
+					/*found = false;*/\
+					if(!found){\
+						gDvm.logRW[gDvm.pointer%10] = false;\
+						gDvm.logValues[gDvm.pointer%10] =_objvalue;\
+						gDvm.logRef[gDvm.pointer%10] =_ref;\
+						gDvm.logType[gDvm.pointer%10] =_objtype;\
+						gDvm.pointer++;\
+						gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].type = FIELD_WRITE;\
+						gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].objType = _objtype;\
+						gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].addr = _objvalue;\
+						gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].offset = _ref;\
+						gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].size = _objsize;\
+						gDvm.fTail++;\
+						gDvm.records[gDvm.tail%TOTALBUFFSIZE] = RECORD_FIELD;\
+						gDvm.threadIds[gDvm.tail%TOTALBUFFSIZE] = _threadid;\
+						gDvm.tail = safeIncre(gDvm.tail);\
+						/*if(gDvm.tail - gDvm.head >= TOTALBUFFSIZE)\
+						  gDvm.stopLogging = true;*/\
+						CHECK_BUFFER();\
+						/*WRITE_BUFFER("%d<w t=%s v=%lu p=%u s=%d/>\n", _threadid, _objtype, _objvalue, _ref, _objsize);*/\
+					}\
+				}\
+			}\
+			pthread_mutex_unlock(&(gDvm.threadLock));\
+		}\
+	}\
+}while(false)
+
+
+/*
+ * The macro to log allocs
+ */
+#define LOG_ALLOC_MCC(_objvalue, _objsize) do{\
+	if(gDvm.isInstrSetupComplete){\
+		if(gDvm.feature==FEATURE_TRACE){\
+			pthread_mutex_lock(&(gDvm.threadLock));\
+			if(!gDvm.compare && !gDvm.stopLogging) {  \
+				int _threadid = (int)self->systemTid;\
+				gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].type = FIELD_ALLOC;\
+				gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].addr = _objvalue;\
+				gDvm.fAccess[gDvm.fTail%TOTALFIELDSIZE].size = _objsize;\
+				gDvm.fTail++;\
+				gDvm.records[gDvm.tail%TOTALBUFFSIZE] = RECORD_FIELD;\
+				gDvm.threadIds[gDvm.tail%TOTALBUFFSIZE] = _threadid;\
+				gDvm.tail = safeIncre(gDvm.tail);\
+				/*	if(gDvm.tail - gDvm.head >= TOTALBUFFSIZE)\
+					gDvm.stopLogging = true;*/\
+				CHECK_BUFFER();\
+				/*WRITE_BUFFER("%d<w t=%s v=%lu p=%u s=%d/>\n", _threadid, _objtype, _objvalue, _ref, _objsize);*/\
+				/*WRITE_BUFFER("%d<a v=%lu s=%d/>\n", _threadid, _objvalue, _objsize);*/\
+			}\
+			pthread_mutex_unlock(&(gDvm.threadLock));\
+		}\
+	}\
+}while(false)
+
+#define LOG_NATIVELIB(_objvalue) do{\
+	if(gDvm.isInstrSetupComplete){\
+		if(gDvm.feature == FEATURE_TRACE){\
+			pthread_mutex_lock(&(gDvm.threadLock));\
+			if(!gDvm.compare) {  \
+				gDvm.libPath = _objvalue;\
+				/*WRITE_BUFFER("1<so p=%s/>\n", _objvalue);*/\
+			}\
+			/*uid_t currUID = getuid();\
+			  if(currUID == 0 || currUID <= 9999){\
+			  FILE* file;\
+			  file = fopen("/data/system/PreloadClasses", "a");\
+			  fprintf(file,"%d<so p='%s'/>\n", currUID,_objvalue);\
+			  fclose(file);\
+			  }*/\
+			pthread_mutex_unlock(&(gDvm.threadLock));\
+		}\
+	}\
+}while(false)
+
+#define LOG_NATIVELIBCALL(_clazz, _objvalue) do{\
+	if(gDvm.isInstrSetupComplete){\
+		if(gDvm.feature==FEATURE_TRACE){\
+			pthread_mutex_lock(&(gDvm.threadLock));\
+			if(!gDvm.compare && !gDvm.stopLogging) {  \
+				gDvm.ntMeth[gDvm.ntTail%TOTALNATIVESIZE].lib = gDvm.libPath;\
+				gDvm.ntMeth[gDvm.ntTail%TOTALNATIVESIZE].clazz = _clazz;\
+				gDvm.ntMeth[gDvm.ntTail%TOTALNATIVESIZE].method = _objvalue;\
+				gDvm.ntTail++;\
+				gDvm.records[gDvm.tail%TOTALBUFFSIZE] = RECORD_NATIVECALL;\
+				gDvm.threadIds[gDvm.tail%TOTALBUFFSIZE] = 1;\
+				gDvm.tail = safeIncre(gDvm.tail);\
+				/*if(gDvm.tail - gDvm.head >= TOTALBUFFSIZE)\
+				  gDvm.stopLogging = true;*/\
+				CHECK_BUFFER();\
+				/*WRITE_BUFFER("1<nl f=%s.%s(%s) so=%s/>\n", _cname, _mname, _sig, _objvalue);*/\
+			}\
+			/*uid_t currUID = getuid();\
+			  if(currUID == 0 || currUID <= 9999)\
+			  {\
+			  FILE* file;\
+			  file = fopen("/data/system/PreloadClasses", "a");\
+			  fprintf(file,"%d<nl f='%s.%s(%s)' so='%s'/>\n", currUID, _cname, _mname, _sig, _objvalue);\
+			  fclose(file);\
+			  }*/\
+			pthread_mutex_unlock(&(gDvm.threadLock));\
+		}\
+	}\
+}while(false)
+
+/*
+ *Get current thread time in microseconds
+ */
+inline u4 getThreadTime(){
+	struct timespec systm;
+	uint32_t time = 0;
+	clock_gettime(CLOCK_THREAD_CPUTIME_ID, &systm);
+	time = systm.tv_sec * 1000000LL + systm.tv_nsec / 1000;
+	return time;
+}
+
+void inline logStartTime(){
+	dvmThreadSelf()->interpStartTime = getThreadTime();
+}
+
+void inline updateTotalTime(){
+	u4 ct = getThreadTime();
+	Thread* self = dvmThreadSelf();
+	self->interpTotalTime += ct - self->interpStartTime;
+}
+
+/*
+ * The macro to log function entrance. 
+ */
+#define LOG_METHOD_ENTRANCE(_addr, _cname,_mname,_sig, _isNative) do{\
+	if(gDvm.isInstrSetupComplete){\
+		if(gDvm.feature==FEATURE_COUNT){\
+			++self->methodCount;\
+			if(!self->hasStarted){\
+				self->hasStarted = true;\
+				self->startTime = getThreadTime();\
+			}\
+		}\
+		else if(gDvm.feature==FEATURE_TIME){\
+			++self->methodCount;\
+			if(!self->hasStarted){\
+				self->hasStarted = true;\
+				self->startTime = getThreadTime();\
+			}\
+			if(!_isNative){\
+				/*from native to java*/\
+				if(self->stack.empty() || dvmIsNativeMethod(self->stack.back())){\
+					logStartTime();\
+				}\
+			}else{\
+				/*from java to native*/\
+				if(!self->stack.empty()){\
+					if(!dvmIsNativeMethod(self->stack.back())){\
+						updateTotalTime();\
+					}\
+				}\
+			}\
+			Method* cm = (Method*)_addr;\
+			self->stack.push_back(cm);\
+			self->topMethod = cm;\
+		}\
+		else if(gDvm.feature==FEATURE_TRACE || gDvm.feature==FEATURE_TRACE_TIME){\
+			pthread_mutex_lock(&(gDvm.threadLock));\
+			if(!gDvm.compare && !gDvm.stopLogging) {  \
+				int _threadid = (int)self->systemTid;\
+				Method* cm = (Method*)_addr;\
+				self->stack.push_back(cm);\
+				self->topMethod = cm;\
+				/*	LOGX("TraceDebug: %u Enter %d %s.%s(%s) isNative=%d at line %d of file %s",self->systemTid,_addr,_cname, _mname, \
+					_sig,(_isNative?1:0), __LINE__,__FILE__);*/ \
+				if(gDvm.compare){\
+					if(gDvm.count > 1000){\
+						gDvm.count=0;\
+						struct timespec systm;\
+						uint32_t systime = 0;\
+						clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &systm);\
+						systime = systm.tv_sec * 1000000LL + systm.tv_nsec / 1000 - gDvm.startTime;\
+						uint32_t _time = 0;\
+						clock_gettime(CLOCK_THREAD_CPUTIME_ID, &systm);\
+						_time = systm.tv_sec * 1000000LL + systm.tv_nsec / 1000;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].addr = _addr;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].isNative = _isNative;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].time = _time;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].sysTime = systime;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].count = self->instrCount;\
+						gDvm.entTail++;\
+						gDvm.records[gDvm.tail%TOTALBUFFSIZE] = RECORD_METH_ENTRY;\
+						gDvm.threadIds[gDvm.tail%TOTALBUFFSIZE] = _threadid;\
+						gDvm.tail = safeIncre(gDvm.tail);\
+						/*WRITE_BUFFER("%d<fun n=%s.%s(%s) a=%u nt=%d t=%lu st=%lu>\n", _threadid, _cname, _mname, _sig, _addr, _isNative?1:0,_time, systime);*/\
+						CHECK_BUFFER();\
+					}\
+					gDvm.count++;\
+				}else if (!gDvm.stopLogging){\
+					gDvm.lastThreadId = 0;\
+					uint32_t _time = 0;\
+					struct timespec systm;\
+					clock_gettime(CLOCK_THREAD_CPUTIME_ID, &systm);\
+					_time = systm.tv_sec * 1000000LL + systm.tv_nsec / 1000;\
+					if(gDvm.count > 1000){\
+						gDvm.count=0;\
+						uint32_t systime = 0;\
+						clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &systm);\
+						systime = systm.tv_sec * 1000000LL + systm.tv_nsec / 1000 - gDvm.startTime;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].addr = _addr;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].isNative = _isNative;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].time = _time;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].sysTime = systime;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].count = self->instrCount;\
+						gDvm.entTail++;\
+						gDvm.records[gDvm.tail%TOTALBUFFSIZE] = RECORD_METH_ENTRY;\
+						gDvm.threadIds[gDvm.tail%TOTALBUFFSIZE] = _threadid;\
+						gDvm.tail = safeIncre(gDvm.tail);\
+						/*if(gDvm.tail - gDvm.head > TOTALBUFFSIZE)\
+						  gDvm.stopLogging = true;*/\
+						CHECK_BUFFER();\
+						/*WRITE_BUFFER("%d<fun n=%s.%s(%s) a=%u nt=%s t=%lu st=%lu>\n", _threadid, _cname, _mname, _sig, _addr, _isNative?"1":"0", _time, systime);*/\
+					}else{ \
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].addr = _addr;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].isNative = _isNative;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].time = _time;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].sysTime = 0;\
+						gDvm.mEntries[gDvm.entTail%TOTALENTSIZE].count = self->instrCount;\
+						gDvm.entTail++;\
+						gDvm.records[gDvm.tail%TOTALBUFFSIZE] = RECORD_METH_ENTRY;\
+						gDvm.threadIds[gDvm.tail%TOTALBUFFSIZE] = _threadid;\
+						gDvm.tail = safeIncre(gDvm.tail);\
+						/*if(gDvm.tail - gDvm.head >= TOTALBUFFSIZE)\
+						  gDvm.stopLogging = true;*/\
+						CHECK_BUFFER();\
+						/*WRITE_BUFFER("%d<fun n=%s.%s(%s) a=%u nt=%s t=%lu>\n", _threadid, _cname, _mname, _sig, _addr, _isNative?"1":"0", _time);*/\
+					}\
+					gDvm.count++;\
+				}\
+			}\
+			pthread_mutex_unlock(&(gDvm.threadLock));\
+		}\
+	}\
+}while(false)
+
+
+/*
+ * The macro to log function exit.
+ */
+#define LOG_METHOD_EXIT(_addr) do{\
+	if(gDvm.isInstrSetupComplete){\
+		if(gDvm.feature == FEATURE_TIME){\
+			if(self->stack.size()>0){\
+				uint32_t mt = (uint32_t)self->stack.back();\
+				if(mt != _addr){\
+					ALOGD("TraceDebug: %u method address don't match when exit: %u, %u", self->systemTid, _addr,mt);\
+					exit(1);\
+				}\
+				Method* cm = (Method*)mt;\
+				self->stack.pop_back();\
+				if(self->stack.empty())\
+				self->topMethod = NULL;\
+				else\
+				self->topMethod = self->stack.back();\
+				/*from native to java*/\
+				if(dvmIsNativeMethod(cm)){\
+					if(!self->stack.empty()){\
+						if(!dvmIsNativeMethod(self->stack.back())){\
+							logStartTime();\
+						}\
+					}\
+					/*from java to native*/\
+				}else{\
+					if(self->stack.empty()||dvmIsNativeMethod(self->stack.back())){\
+						updateTotalTime();\
+					}\
+				}\
+			}\
+			else\
+			ALOGD("TraceDebug: %u stack size is 0.", self->systemTid); \
+		}\
+		else if(gDvm.feature == FEATURE_TRACE || gDvm.feature == FEATURE_TRACE_TIME){\
+			pthread_mutex_lock(&(gDvm.threadLock));\
+			if(!gDvm.compare && !gDvm.stopLogging) {  \
+				if(self->stack.size()>0){\
+					uint32_t mt = (uint32_t)self->stack.back();\
+					if(mt != _addr){\
+						ALOGD("TraceDebug: %u method address don't match when exit: %u, %u", self->systemTid, _addr,mt);\
+					}\
+					self->stack.pop_back();\
+					if(self->stack.empty())\
+					self->topMethod = NULL;\
+					else\
+					self->topMethod = self->stack.back();\
+				}\
+				else{\
+				LOGX("TraceDebug: %u stack size is 0.", self->systemTid); }\
+				/*LOGX("TraceDebug: Leave %d at line %d of file %s",_addr, __LINE__, __FILE__);*/ \
+				int _threadid = (int) self->systemTid;\
+				gDvm.lastThreadId = 0;\
+				uint32_t _time = 0;\
+				struct timespec systm;\
+				clock_gettime(CLOCK_THREAD_CPUTIME_ID, &systm);\
+				_time = systm.tv_sec * 1000000LL + systm.tv_nsec / 1000;\
+				gDvm.mExits[gDvm.exTail%TOTALEXITSIZE].addr = _addr;\
+				gDvm.mExits[gDvm.exTail%TOTALEXITSIZE].time = _time;\
+				gDvm.mExits[gDvm.exTail%TOTALEXITSIZE].count = self->instrCount;\
+				gDvm.exTail++;\
+				gDvm.records[gDvm.tail%TOTALBUFFSIZE] = RECORD_METH_EXIT;\
+				gDvm.threadIds[gDvm.tail%TOTALBUFFSIZE] = _threadid;\
+				gDvm.tail = safeIncre(gDvm.tail);\
+				/*	if(gDvm.tail - gDvm.head >= TOTALBUFFSIZE)\
+					gDvm.stopLogging = true;*/\
+				CHECK_BUFFER();\
+				/*WRITE_BUFFER("%u</fun a=%u t=%lu>\n",_threadid,_addr ,_time);*/\
+			}\
+			pthread_mutex_unlock(&(gDvm.threadLock));\
+		}\
+	}\
+}while(false)
+
+/*
+ * The macro should be always called after a frame is popped
+ */
+#define LOG_METHOD_EXIT_WITH_CHECK(_addr) do{\
+	if(gDvm.feature == FEATURE_TRACE || gDvm.feature == FEATURE_TIME || gDvm.feature == FEATURE_TRACE_TIME)\
+	if(gDvm.isInstrSetupComplete  && !gDvm.stopLogging) {\
+		if(self->stack.size()>0){\
+			uint32_t mt = (uint32_t)self->stack.back();\
+			if(mt != _addr){\
+				LOGX("TraceDebug: %u method address don't match when exit: %u, %u", self->systemTid, _addr,mt);\
+				FIX_STACK(self);\
+			} else\
+			LOG_METHOD_EXIT(_addr);\
+		}else{\
+			FIX_STACK(self);\
+		}\
+	}\
+}while(false)\
+
+
+#define FLUSH_LOG() do{\
+	pthread_mutex_lock(&(gDvm.threadLock));\
+	fflush(gDvm.fHandle);\
+	pthread_mutex_unlock(&(gDvm.threadLock));\
+}while(false)
+
+#define CLOSE_LOG() do{\
+    u4 i = 0;\
+    for(; i < gDvm.fileArrayLength; i++){\
+ 	if(gDvm.fileArray[i]){\
+	fflush(gDvm.fileArray[i]);\
+	fclose(gDvm.fileArray[i]);\
+	}\
+    }\
+}while(false)
+
+inline bool CHECK_STACK_SIZE(Thread* self){
+	u4* fp = self->interpSave.curFrame; 
+	u4 depth = 0;
+	while (fp != NULL) { 
+		if (!dvmIsBreakFrame((u4*)fp)) { 
+			depth++;
+		} 
+		fp = SAVEAREA_FROM_FP(fp)->prevFrame;
+	}
+	return depth == self->stack.size();
+}
+
+/**
+ * The function to fix call return mismatch
+ */
+inline void FIX_STACK(Thread* _thread){
+	Thread* self = _thread;
+	LOGX("TraceDebug: %u fix call-return", self->systemTid); 
+	u4* fp = self->interpSave.curFrame; 
+	std::vector<const Method*> dStack; 
+	while (fp != NULL) { 
+		if (!dvmIsBreakFrame((u4*)fp)) { 
+			dStack.push_back(SAVEAREA_FROM_FP(fp)->method); 
+		} 
+		fp = SAVEAREA_FROM_FP(fp)->prevFrame;
+	}
+	int i = 0;
+	int dsDep = (int)dStack.size();
+	int isDep = (int)self->stack.size();
+	for(;i < dsDep && i < isDep; i++){
+		if(dStack[dsDep-1-i] != self->stack[i])
+		break;
+	}
+
+#ifdef XIN_DEBUG
+	LOGX("TraceDebug: %u dalvik stack:", self->systemTid); 
+	for(int j = 0; j < dsDep; j++){
+		const Method* methodToCall = dStack[j];
+		LOGX("TraceDebug: %u %s.%s(%s) isNative=%d",self->systemTid,methodToCall->clazz->descriptor, methodToCall->name, 
+				methodToCall->shorty,(dvmIsNativeMethod(methodToCall)?1:0)); 
+	}
+	LOGX("TraceDebug: %u trace stack before fix:", self->systemTid);
+	for(int j = isDep-1; j >=0 ;j--){
+		Method* methodToCall = self->stack[j];
+		LOGX("TraceDebug: %u %s.%s(%s) isNative=%d",self->systemTid,methodToCall->clazz->descriptor, methodToCall->name, 
+				methodToCall->shorty,(dvmIsNativeMethod(methodToCall)?1:0)); 
+	}
+#endif
+	self->isInFix = true;
+	LOGX("TraceDebug: %u diff point: %d %d %d", self->systemTid, i, dsDep, isDep);
+	for(int j = isDep-1; j >= i; j--){
+		uint32_t maddr = (uint32_t)self->stack[j];
+		LOG_METHOD_EXIT(maddr);
+	}
+	for(int j = dsDep-1-i; j >=0 ; j--){
+		const Method* methodToCall = dStack[j];
+		LOG_METHOD_ENTRANCE((uint32_t)methodToCall, methodToCall->clazz->descriptor, methodToCall->name, 
+				methodToCall->shorty,dvmIsNativeMethod(methodToCall));
+	}
+	self->isInFix = false;
+#ifdef XIN_DEBUG
+	LOGX("TraceDebug: %u trace stack after fix:", self->systemTid);
+	for(int j = self->stack.size()-1; j >=0 ;j--){
+		Method* methodToCall = self->stack[j];
+		LOGX("TraceDebug: %u %s.%s(%s) isNative=%d",self->systemTid,methodToCall->clazz->descriptor, methodToCall->name, 
+				methodToCall->shorty,(dvmIsNativeMethod(methodToCall)?1:0)); 
+	}
+#endif
+} 
+
+inline void CHECK_STACK_NATIVE(Thread* self){
+	if(self->stack.empty()||!dvmIsNativeMethod(self->stack.back()))	
+		FIX_STACK(self);
+}
+
+static inline bool isMethTracked(const Method* m){
+	if(gDvm.trackedColocMap->find(m) != gDvm.trackedColocMap->end())
+		return (*gDvm.trackedColocMap)[m];
+	std::string fullname = std::string(m->clazz->descriptor)+"."+std::string(m->name)+"("+ m->shorty+")";
+	bool ret = false;
+	if(std::find(gDvm.trackedColocMeths->begin(),gDvm.trackedColocMeths->end(),fullname) != gDvm.trackedColocMeths->end()){
+		LOGX("trackedMethods: %s", fullname.c_str());
+		ret = true;
+	}
+	(*gDvm.trackedColocMap)[m] = ret;
+	return ret;
+//	return dvmIsNativeMethod(m);
+}
+
+static inline bool isMethInstrumented(const Method* m){
+	if(!dvmIsNativeMethod(m))
+		return false;
+	if(!gDvm.isInstrSetupComplete)
+		return false;
+	Thread* self = dvmThreadSelf();		
+	return (int)gDvm.guiThreadId != self->systemTid;
+//	if(!dvmIsNativeMethod(m))
+//		return false;
+//	if(!gDvm.isInstrSetupComplete)
+//		return false;
+//	if(gDvm.instrumentedMeths == NULL || gDvm.instrumentedMeths->size() == 0)
+//		return true;
+//	u4 maddr = (u4)m;
+//	if(gDvm.imCache->find(maddr) == gDvm.imCache->end()){
+//		std::string fullname = std::string(m->clazz->descriptor)+"."+std::string(m->name)+"("+ m->shorty+")";
+//		if(std::find(gDvm.instrumentedMeths->begin(),gDvm.instrumentedMeths->end(),fullname) != gDvm.instrumentedMeths->end()){
+//		             (*gDvm.imCache)[maddr] = true;
+//		}
+//		else
+//			(*gDvm.imCache)[maddr] = false;
+//	}
+//	return (*gDvm.imCache)[maddr];
+}
+
+static inline void  LOG_WRITE_RET(const Method* meth, s8 _ret){
+	if(gDvm.isInstrSetupComplete && gDvm.feature==FEATURE_TRACE && isMethTracked(meth)){
+		u8 ur = (u8)_ret;
+		u4 hbs = (u4)(ur >> 32);
+		u4 lbs = (u4)(ur & 0x00000000FFFFFFFF);
+		Thread* self = dvmThreadSelf();
+		LOG_WRITE(OBJ_RET, lbs, 0, 8);
+		LOG_WRITE(OBJ_RET, hbs, 0, 8);
+	}
+}
+
+static inline void LOG_READ_RET(const Method* meth, s8 _ret){
+	if(gDvm.isInstrSetupComplete && gDvm.feature==FEATURE_TRACE && isMethTracked(meth)){
+		u8 ur = (u8)_ret;
+		u4 hbs = (u4)(ur >> 32);
+		u4 lbs = (u4)(ur & 0x00000000FFFFFFFF);
+		Thread* self = dvmThreadSelf();
+		LOG_READ(OBJ_RET, lbs, 0, 8);
+		LOG_READ(OBJ_RET, hbs, 0, 8);
+	}
+}
+
+static inline void LOG_WRITE_PARAM(const Method* meth, u4* argv, u4 argc){
+	if(gDvm.isInstrSetupComplete && gDvm.feature==FEATURE_TRACE && isMethTracked(meth)){
+		Thread* self = dvmThreadSelf();
+		for(u4 j = 0 ; j < argc ;j++){
+			LOG_WRITE(OBJ_REGISTER, argv[j], 0, 4);
+		}
+	}
+}
+
+static inline void LOG_READ_PARAM(const Method* meth, u4* argv, u4 argc){
+	if(gDvm.isInstrSetupComplete && gDvm.feature==FEATURE_TRACE && isMethTracked(meth)){
+		Thread* self = dvmThreadSelf();
+		for(u4 j = 0 ; j < argc ;j++){
+			LOG_READ(OBJ_REGISTER, argv[j], 0, 4);
+		}
+	}
+}
+
+#endif
+//*********************Macros for instruction logging****************/
+
 #endif  // DALVIK_GLOBALS_H_
diff --git a/vm/Init.cpp b/vm/Init.cpp
index 9169a5d..8ef4071 100644
--- a/vm/Init.cpp
+++ b/vm/Init.cpp
@@ -36,6 +36,7 @@
 #include "test/Test.h"
 #include "mterp/Mterp.h"
 #include "Hash.h"
+#include <fstream>
 
 #if defined(WITH_JIT)
 #include "compiler/codegen/Optimizer.h"
@@ -1333,6 +1334,7 @@ static void blockSignals()
     sigemptyset(&mask);
     sigaddset(&mask, SIGQUIT);
     sigaddset(&mask, SIGUSR1);      // used to initiate heap dump
+    sigaddset(&mask, SIGINT);
 #if defined(WITH_JIT) && defined(WITH_JIT_TUNING)
     sigaddset(&mask, SIGUSR2);      // used to investigate JIT internals
 #endif
@@ -1532,6 +1534,7 @@ std::string dvmStartup(int argc, const char* const argv[],
         return "dvmCreateStockExceptions failed";
     }
 
+
     /*
      * At this point, the VM is in a pretty good state.  Finish prep on
      * the main thread (specifically, create a java.lang.Thread object to go
@@ -1588,6 +1591,11 @@ std::string dvmStartup(int argc, const char* const argv[],
         return "Exception pending at end of VM initialization";
     }
 
+    //Start instrumentation.
+   uid_t uid1, uid2, uid3;
+   getresuid(&uid1, &uid2, &uid3);
+   setupInstrumentation(uid1);
+
     scopedShutdown.disarm();
     return "";
 }
@@ -1952,7 +1960,6 @@ fail:
 void dvmShutdown()
 {
     ALOGV("VM shutting down");
-
     if (CALC_CACHE_STATS)
         dvmDumpAtomicCacheStats(gDvm.instanceofCache);
 
@@ -2157,3 +2164,412 @@ void dvmAbort()
 
     /* notreached */
 }
+
+/*
+ *Begin: code to force big-endian output
+ *
+ */
+short shortSwap( short s )
+{
+	unsigned char b1, b2;
+
+	b1 = s & 255;
+	b2 = (s >> 8) & 255;
+
+	return (b1 << 8) + b2;
+}
+
+short shortNoSwap(short s){
+	return s;
+}
+
+u4 u4Swap(u4 u){
+	unsigned char b1,b2,b3,b4;
+	b1 = u & 255;
+	b2 = (u>>8) & 255;
+	b3 = (u>>16) & 255;
+	b4 = (u>>24) & 255;
+	return ((u4)b1 << 24) + ((u4)b2 << 16) + ((u4)b3 << 8) + b4; 
+}
+
+u4 u4NoSwap(u4 u){
+	return u;
+}
+
+short (*bigShort) (short s);
+u4 (*bigU4)(u4 u);
+
+
+void setBigEndian(){
+	union {
+		char theChars[2];
+		short theShort;
+	} swapTest;
+	swapTest.theChars[0] = 1;
+	swapTest.theChars[1] = 0;
+	if(swapTest.theShort == 1){
+	//little endian system
+	bigShort = shortSwap;
+	bigU4 = u4Swap;
+	}
+	else{
+	//big endian
+	bigShort = shortNoSwap;
+	bigU4 = u4NoSwap;
+	}
+}
+
+/*
+ *End: code to force big-endian output
+ *
+ */
+
+void* flushlogtrace(void *arg)
+{
+	char methNameBuf[1024];
+        while(true){
+		int sleeptime = 0;
+		unsigned long tail = gDvm.tail;
+		bool toflush = false;
+		if(tail > gDvm.head)
+			toflush = true;
+		if(tail - gDvm.head < 1000)
+			sleeptime =1;
+		
+		for(; gDvm.head < tail; gDvm.head++){
+			int record = (int)gDvm.records[gDvm.head % TOTALBUFFSIZE];
+			int _threadid = gDvm.threadIds[gDvm.head % TOTALBUFFSIZE];
+			if (record == RECORD_METH_ENTRY){
+				//method entry
+				MethEntry* entry =  gDvm.mEntries + gDvm.entHead % TOTALENTSIZE;
+				Method* m = (Method*) entry->addr;
+				if(FORMAT_PLAIN == gDvm.format || FORMAT_DEBUG == gDvm.format){
+			//		if(entry->sysTime > 0)
+			//			WRITE_BUFFER("%d<fun n=%s.%s(%s) a=%u nt=%s t=%u st=%u>\n", _threadid, m->clazz->descriptor, m->name, m->shorty, entry->addr, entry->isNative?"1":"0", entry->time, entry->sysTime);
+			//		else
+					WRITE_BUFFER("%d<fun n=%s.%s(%s) a=%u nt=%s t=%u c=%u>\n", _threadid, m->clazz->descriptor, m->name, m->shorty, entry->addr, entry->isNative?"1":"0", entry->time,entry->count);
+				}
+				if(FORMAT_BIN == gDvm.format || FORMAT_DEBUG == gDvm.format){
+					char instrType = INSTR_ENTRY;
+					short instrThreId = bigShort((short)_threadid);
+					u4 time = bigU4(entry->time);
+					u4 count = bigU4(entry->count);
+					u4 addr = bigU4(entry->addr);
+					char isNative = (entry->isNative?1:0);
+					SAFE_FWRITE(&instrType, sizeof(instrType),1);
+					SAFE_FWRITE(&instrThreId, sizeof(instrThreId),1);
+					SAFE_FWRITE(&time, sizeof(time),1);
+					SAFE_FWRITE(&count,sizeof(count),1);
+					SAFE_FWRITE(&addr,sizeof(addr),1);
+					SAFE_FWRITE(&isNative,sizeof(isNative),1);
+					int length = snprintf(methNameBuf,sizeof(methNameBuf),"%s.%s(%s) ", m->clazz->descriptor, m->name, m->shorty); 
+					SAFE_FWRITE(methNameBuf,sizeof(char), length);
+				}
+				gDvm.entHead++;
+			}
+			else if (record == RECORD_METH_EXIT){
+				//method exit
+				MethExit* et =  gDvm.mExits + gDvm.exHead % TOTALEXITSIZE;
+				if(FORMAT_PLAIN == gDvm.format || FORMAT_DEBUG == gDvm.format){
+					WRITE_BUFFER("%u</fun a=%u t=%u c=%u>\n",_threadid,et->addr,et->time,et->count);
+				}
+				if(FORMAT_BIN == gDvm.format || FORMAT_DEBUG == gDvm.format){
+					char instrType = INSTR_EXIT;
+					short instrThreId = bigShort((short)_threadid);
+					u4 time = bigU4(et->time);
+					u4 count = bigU4(et->count);
+					u4 addr = bigU4(et->addr);
+					SAFE_FWRITE(&instrType, sizeof(instrType),1);
+					SAFE_FWRITE(&instrThreId, sizeof(instrThreId),1);
+					SAFE_FWRITE(&time, sizeof(time),1);
+					SAFE_FWRITE(&count,sizeof(count),1);
+					SAFE_FWRITE(&addr,sizeof(addr),1);
+				}
+				gDvm.exHead++;
+			}
+			else if(record == RECORD_FIELD){
+				//field access
+				FieldAccess* field =  gDvm.fAccess + gDvm.fHead % TOTALFIELDSIZE;
+				if(field->type == FIELD_ALLOC){
+					//alloc
+					if(FORMAT_PLAIN == gDvm.format){
+						WRITE_BUFFER("%d<a v=%u s=%d/>\n", _threadid, field->addr, field->size);
+					}
+					else{
+					//do nothing	
+						char instrType = INSTR_ALLOC;
+						short instrThreId = bigShort((short)_threadid);
+						u4 addr = bigU4(field->addr);
+						u4 size = bigU4(field->size);
+						SAFE_FWRITE(&instrType, sizeof(instrType),1);
+						SAFE_FWRITE(&instrThreId, sizeof(instrThreId),1);
+						SAFE_FWRITE(&addr,sizeof(addr),1);
+						SAFE_FWRITE(&size,sizeof(size),1);
+					}
+				}
+				else if(field->type == FIELD_READ){
+					//read
+					if(FORMAT_PLAIN == gDvm.format || FORMAT_DEBUG == gDvm.format){
+						WRITE_BUFFER("%d<r t=%d v=%u p=%u s=%d/>\n", _threadid, field->objType,  field->addr, field->offset, field->size);
+					}
+					if(FORMAT_BIN == gDvm.format || FORMAT_DEBUG == gDvm.format){
+						char instrType = INSTR_READ;
+						short instrThreId = bigShort((short)_threadid);
+						char objType = (char)field->objType;
+						u4 addr = bigU4(field->addr);
+						u4 size = bigU4(field->size);
+						u4 offset = bigU4(field->offset);
+						SAFE_FWRITE(&instrType, sizeof(instrType),1);
+						SAFE_FWRITE(&instrThreId, sizeof(instrThreId),1);
+						SAFE_FWRITE(&objType,sizeof(objType),1);
+						SAFE_FWRITE(&addr,sizeof(addr),1);
+						SAFE_FWRITE(&size,sizeof(size),1);
+						SAFE_FWRITE(&offset,sizeof(offset),1);
+					}
+				}
+				else if(field->type == FIELD_WRITE){
+					//write
+					if(FORMAT_PLAIN == gDvm.format || FORMAT_DEBUG == gDvm.format){
+						WRITE_BUFFER("%d<w t=%d v=%u p=%u s=%d/>\n", _threadid, field->objType,  field->addr, field->offset, field->size);
+					}
+					if(FORMAT_BIN == gDvm.format || FORMAT_DEBUG == gDvm.format){
+						char instrType = INSTR_WRITE;
+						short instrThreId = bigShort((short)_threadid);
+						char objType = (char)field->objType;
+						u4 addr = bigU4(field->addr);
+						u4 size = bigU4(field->size);
+						u4 offset = bigU4(field->offset);
+						SAFE_FWRITE(&instrType, sizeof(instrType),1);
+						SAFE_FWRITE(&instrThreId, sizeof(instrThreId),1);
+						SAFE_FWRITE(&objType,sizeof(objType),1);
+						SAFE_FWRITE(&addr,sizeof(addr),1);
+						SAFE_FWRITE(&size,sizeof(size),1);
+						SAFE_FWRITE(&offset,sizeof(offset),1); }
+				}
+				gDvm.fHead++;
+			}
+			else if(record == RECORD_NATIVECALL){
+				//native lib
+				NativeMeth* nt = gDvm.ntMeth + gDvm.ntHead % TOTALNATIVESIZE;
+				if(FORMAT_PLAIN == gDvm.format || FORMAT_DEBUG == gDvm.format){
+					WRITE_BUFFER("%d<nl f=%s.%s(%s) so=%s/>\n", _threadid, nt->clazz->descriptor, nt->method.name, nt->method.signature, nt->lib);
+				}
+				if(FORMAT_BIN == gDvm.format || FORMAT_DEBUG == gDvm.format){
+					char instrType = INSTR_NATIVE;
+					SAFE_FWRITE(&instrType, sizeof(instrType),1);
+					int length = snprintf(methNameBuf,sizeof(methNameBuf),"%s.%s(%s) %s ", nt->clazz->descriptor, nt->method.name, nt->method.signature,nt->lib); 
+					SAFE_FWRITE(&methNameBuf,sizeof(char), length);
+				}
+				gDvm.ntHead++;
+			}
+		}
+		if(toflush){
+			FLUSH_FILE();
+		}
+		if(sleeptime > 0){
+        		sleep(sleeptime);
+		}
+	}
+        return NULL;
+}
+
+void initColocTrackedMethod(){
+	ALOGD("About to load the colocation file");
+	//potential memory leak?
+	if(gDvm.trackedColocMeths != NULL){
+		gDvm.trackedColocMeths->clear();
+	}else
+		gDvm.trackedColocMeths = new std::vector<std::string>();
+	if(gDvm.trackedColocMap != NULL){
+		gDvm.trackedColocMap->clear();
+	}
+	else
+		gDvm.trackedColocMap = new std::map<const Method*,bool>();
+	std::ifstream configFile;
+	configFile.open("/sdcard/tracked_methods.txt",std::ios::in);	
+	std::string tmpStr;
+	ALOGD("File opened");
+	if(configFile.is_open()){
+		while(std::getline(configFile,tmpStr)){
+			std::string trimStr = trim(tmpStr);
+			ALOGD("Adding method: %s",trimStr.c_str());
+			if(trimStr != "")
+				gDvm.trackedColocMeths->push_back(trimStr);
+		}
+		ALOGD("tracked set created: ");
+		for(std::vector<std::string>::iterator it = gDvm.trackedColocMeths->begin(); it != gDvm.trackedColocMeths->end(); ++it)
+			ALOGD("%s",it->c_str());
+	}else{
+		ALOGD("Please create /sdcard/tracked_methods.txt for methods that need tracking return value and paramters.");	
+	}
+	configFile.close();
+}
+
+void initInstrumentedMethod(){
+	ALOGD("About to load file of native methods to instrument.");
+	std::ifstream configFile;
+	configFile.open("/sdcard/instrumentedMethods.txt",std::ios::in);
+	std::string tmpStr;
+//	if(gDvm.instrumentedMeths != NULL){
+//		gDvm.instrumentedMeths->clear();
+//	}else
+//		gDvm.instrumentedMeths = new std::vector<std::string>();
+//	if(gDvm.imCache != NULL){
+//		gDvm.imCache->clear();
+//	}else
+//		gDvm.imCache = new std::map<u4,bool>();
+//	if(configFile.is_open()){
+//		while(std::getline(configFile,tmpStr)){
+//			std::string trimStr = trim(tmpStr);
+//			ALOGD("Adding method: %s",trimStr.c_str());
+//			if(trimStr != "")
+//				gDvm.instrumentedMeths->push_back(trimStr);
+//		}
+//	}else{
+//		ALOGD("Instrument all native methods by default. If you don't want to instrument anything, simply don't attach pin.");
+//	}
+	if(configFile.is_open()){
+		Thread* self = dvmThreadSelf();		
+		gDvm.guiThreadId = self->systemTid;
+	}else{
+		gDvm.guiThreadId = 0;	
+	}
+	configFile.close();
+}
+						
+
+void setupInstrumentation(uid_t uid){
+	if(!gDvm.isInstrSetupComplete){
+		pthread_mutex_init(&(gDvm.threadLock),NULL);
+		FILE* file;
+		file = fopen("/sdcard/instrTrace.txt", "r");
+		uint32_t targetUID;
+		uint32_t targetFeature;
+		u4 traceFormat;
+		gDvm.feature = FEATURE_NONE;
+		if (file){
+			if(fscanf(file, "%d", &targetUID)!=EOF) {
+				LOGX("TraceDebug:DalvikTraceGen Provided UID:%d\n",targetUID);
+				LOGX("TraceDebug:Build version 1");
+				if(fscanf(file,"%d",&targetFeature)!=EOF && fscanf(file,"%d",&traceFormat)){
+					LOGX("Feature read: %d\n",targetFeature);
+					LOGX("Trace format read: %d\n",traceFormat);
+					if(uid == targetUID) {
+						pid_t ppid = getppid();
+						ALOGD("Started from %u", ppid);
+						LOGX("TraceDebug: size of u4: %u", sizeof(u4));
+						LOGX("TraceDebug: size of char: %u", sizeof(char));
+						LOGX("TraceDebug: size of short: %u", sizeof(short));
+
+						setBigEndian();
+						if(sizeof(short)!=2 || sizeof(u4)!=4 || sizeof(char) !=1 ){//I hate this platform dependent crap of C++
+							ALOGD("Check of primitive type sizes failed");
+						}
+						gDvm.feature = targetFeature;	
+						gDvm.format = traceFormat;
+						gDvm.isInstrSetupComplete = true;
+						gDvm.targetInstrUID = targetUID;
+						gDvm.lastThreadId = 0;
+						gDvm.pointer = 0;
+						if(gDvm.feature == FEATURE_TRACE || gDvm.feature == FEATURE_TRACE_TIME){
+							struct timespec systm;
+							clock_gettime(CLOCK_REALTIME, &systm);
+							gDvm.startTime = systm.tv_sec * 1000000LL + systm.tv_nsec / 1000;
+							gDvm.count = 0;
+
+							FILE* f;
+							f = fopen("/sdcard/compare", "r");
+							if(f){
+								gDvm.compare = true;
+								fclose(f);
+							}else {
+								gDvm.compare = false;
+							}
+							gDvm.records = (short *)malloc(sizeof(short)*TOTALBUFFSIZE);
+							gDvm.threadIds = (int *)malloc(sizeof(int)*TOTALBUFFSIZE);
+							gDvm.stopLogging = false;
+							gDvm.head = 0;
+							gDvm.tail = 0;
+							gDvm.mEntries = (MethEntry*)malloc(sizeof(MethEntry)*TOTALENTSIZE);
+							gDvm.entHead = 0;
+							gDvm.entTail = 0;
+							gDvm.mExits = (MethExit*)malloc(sizeof(MethExit)*TOTALEXITSIZE);
+							gDvm.exHead = 0;
+							gDvm.exTail = 0;
+							gDvm.fAccess = (FieldAccess*)malloc(sizeof(FieldAccess)*TOTALFIELDSIZE);
+							gDvm.fHead = 0;
+							gDvm.fTail = 0;
+							gDvm.ntMeth = (NativeMeth* )malloc(sizeof(NativeMeth)*TOTALNATIVESIZE);
+							gDvm.ntHead = 0;
+							gDvm.ntTail = 0;
+
+							//ADJUST_FILEARRAY_LENGTH(20);
+							//LOGD("TraceDebug:DalvikTraceGen Initialized, target UID:%d\n",gDvm.targetInstrUID);
+							if(gDvm.executionMode != kExecutionModeInterpPortable){
+								gDvm.executionMode = kExecutionModeInterpPortable;
+							}
+							pid_t pid = getpid();
+							char outName[50];
+							sprintf(outName,"/sdcard/TraceOut-%d.txt",pid);
+							char debugName[50];
+							sprintf(debugName,"/sdcard/DebugOut-%d.txt",pid);
+
+							gDvm.fHandle = fopen(outName,"wb");
+
+							int sbr = setvbuf(gDvm.fHandle, NULL, _IOFBF, LOG_CACHE_SIZE);
+							ALOGD("Cache size %u",LOG_CACHE_SIZE);
+							if(0 != sbr){
+								ALOGD("Set buffer to size %u failed with error code %d", LOG_CACHE_SIZE, sbr);	
+								exit(1);
+							}
+							if(FORMAT_DEBUG == gDvm.format){
+								gDvm.dHandle = fopen(debugName,"wb");
+								int sbr1 = setvbuf(gDvm.dHandle, NULL, _IOFBF, LOG_CACHE_SIZE);
+								if(0 != sbr1){
+									ALOGD("Set buffer to size %u failed with error code %d", LOG_CACHE_SIZE, sbr1);
+									exit(1);
+								}
+							}
+
+							initColocTrackedMethod();
+
+							//Load instrumented native methods from the disk
+							initInstrumentedMethod();	
+							pthread_t thread;
+							pthread_create(&thread, NULL, flushlogtrace, (void*)&targetUID);
+
+						}//end if for the feature to be trace case
+						else if(gDvm.feature == FEATURE_COUNT){
+							LOGX("TraceDebug: Finish count logging initialization");
+							gDvm.isBoundHit=false;
+							if(gDvm.executionMode != kExecutionModeInterpPortable){
+								gDvm.executionMode = kExecutionModeInterpPortable;
+							}
+						}
+						else if(gDvm.feature == FEATURE_TIME){
+							LOGX("TraceDebug: Finish time logging initialization");
+							gDvm.isBoundHit=false;
+							if(gDvm.executionMode != kExecutionModeInterpPortable){
+								gDvm.executionMode = kExecutionModeInterpPortable;
+							}
+
+						}
+						else if(gDvm.feature == FEATURE_PIN_TIME){
+							LOGX("TraceDebug: Finish sys call tiem logging initialization.");
+							gDvm.isBoundHit=false;
+							if(gDvm.executionMode != kExecutionModeInterpPortable){
+								gDvm.executionMode = kExecutionModeInterpPortable;
+							}
+						}
+						else if(gDvm.feature == FEATURE_NONE){
+							if(gDvm.executionMode != kExecutionModeInterpPortable){
+								gDvm.executionMode = kExecutionModeInterpPortable;
+							}
+						}
+					}//end if for uid comparison
+				}//end if for feature read
+			}//endif for uid read
+			fclose(file);
+		}
+	}
+}
diff --git a/vm/Init.h b/vm/Init.h
index 1b585fa..a53178f 100644
--- a/vm/Init.h
+++ b/vm/Init.h
@@ -20,6 +20,8 @@
 #ifndef DALVIK_INIT_H_
 #define DALVIK_INIT_H_
 
+void setupInstrumentation(uid_t uid);
+
 /*
  * Standard VM initialization, usually invoked through JNI.
  */
diff --git a/vm/InlineNative.cpp b/vm/InlineNative.cpp
index 00c1e95..a0e64ae 100644
--- a/vm/InlineNative.cpp
+++ b/vm/InlineNative.cpp
@@ -138,15 +138,37 @@ bool javaLangString_charAt(u4 arg0, u4 arg1, u4 arg2, u4 arg3,
 
     //ALOGI("String.charAt this=0x%08x index=%d", arg0, arg1);
     count = dvmGetFieldInt((Object*) arg0, STRING_FIELDOFF_COUNT);
+
+    Thread* self = dvmThreadSelf();
+
+    CHECK_STACK_NATIVE(self);
+
+    Object* obj = (Object*)arg0;
+
+    ////An overapproximation. Charge only one read. But note now the offset is not right
+    //LOG_READ(OBJ_JNI, arg0,0, obj->clazz->objectSize);
+
+    LOG_READ(OBJ_JNI, arg0,STRING_FIELDOFF_COUNT, obj->clazz->objectSize);
+
     if ((s4) arg1 < 0 || (s4) arg1 >= count) {
         dvmThrowStringIndexOutOfBoundsExceptionWithIndex(count, arg1);
         return false;
     } else {
         offset = dvmGetFieldInt((Object*) arg0, STRING_FIELDOFF_OFFSET);
+
+	LOG_READ(OBJ_JNI, arg0,STRING_FIELDOFF_OFFSET, obj->clazz->objectSize);	
+
         chars = (ArrayObject*)
             dvmGetFieldObject((Object*) arg0, STRING_FIELDOFF_VALUE);
 
+	LOG_READ(OBJ_JNI, arg0,STRING_FIELDOFF_VALUE, obj->clazz->objectSize);	
+
         pResult->i = ((const u2*)(void*)chars->contents)[arg1 + offset];
+	
+	u4 arrAddr = (u4)chars;
+
+	LOG_READ(OBJ_JNI_ARRAY, arrAddr,(offset+arg1)*sizeof(u2), dvmArrayObjectSize(chars));	
+
         return true;
     }
 }
@@ -230,17 +252,52 @@ bool javaLangString_compareTo(u4 arg0, u4 arg1, u4 arg2, u4 arg3,
 
     thisCount = dvmGetFieldInt((Object*) arg0, STRING_FIELDOFF_COUNT);
     compCount = dvmGetFieldInt((Object*) arg1, STRING_FIELDOFF_COUNT);
+
+    Thread* self = dvmThreadSelf();
+
+    CHECK_STACK_NATIVE(self);
+
+    Object* thisObj = (Object*)arg0;
+    LOG_READ(OBJ_JNI, arg0,STRING_FIELDOFF_COUNT, thisObj->clazz->objectSize);
+    Object* thatObj = (Object*)arg1;
+    LOG_READ(OBJ_JNI, arg1,STRING_FIELDOFF_COUNT, thatObj->clazz->objectSize);
+
     countDiff = thisCount - compCount;
     minCount = (countDiff < 0) ? thisCount : compCount;
     thisOffset = dvmGetFieldInt((Object*) arg0, STRING_FIELDOFF_OFFSET);
     compOffset = dvmGetFieldInt((Object*) arg1, STRING_FIELDOFF_OFFSET);
+
+    LOG_READ(OBJ_JNI, arg0,STRING_FIELDOFF_OFFSET, thisObj->clazz->objectSize);
+    LOG_READ(OBJ_JNI, arg1,STRING_FIELDOFF_OFFSET, thatObj->clazz->objectSize);
+
     thisArray = (ArrayObject*)
         dvmGetFieldObject((Object*) arg0, STRING_FIELDOFF_VALUE);
     compArray = (ArrayObject*)
         dvmGetFieldObject((Object*) arg1, STRING_FIELDOFF_VALUE);
+
+    LOG_READ(OBJ_JNI, arg0,STRING_FIELDOFF_VALUE, thisObj->clazz->objectSize);
+    LOG_READ(OBJ_JNI, arg1,STRING_FIELDOFF_VALUE, thatObj->clazz->objectSize);
+  
+    //LOG_READ(OBJ_JNI, arg0,0, thisObj->clazz->objectSize);
+    //LOG_READ(OBJ_JNI, arg1,0, thatObj->clazz->objectSize);
+
     thisChars = ((const u2*)(void*)thisArray->contents) + thisOffset;
     compChars = ((const u2*)(void*)compArray->contents) + compOffset;
 
+    u4 thisAddr = (u4)thisArray;
+    u4 thatAddr = (u4)compArray;
+
+   // //A bit irritating to log the accesses to every single element in the array.
+   // int itemp;
+   // for(itemp = 0; itemp < minCount; itemp++){
+   //         LOG_READ(OBJ_JNI_ARRAY, thisAddr,(itemp+thisOffset)*sizeof(u2), dvmArrayObjectSize(thisArray));	
+   //         LOG_READ(OBJ_JNI_ARRAY, thatAddr,(itemp+compOffset)*sizeof(u2), dvmArrayObjectSize(compArray));	
+   //         if(thisChars[itemp] != compChars[itemp])
+   //     	    break;
+   // }
+
+    LOG_READ(OBJ_ARRAY_ALL, thisAddr ,0, dvmArrayObjectSize(thisArray));
+    LOG_READ(OBJ_ARRAY_ALL, thatAddr, 0, dvmArrayObjectSize(compArray));
 #ifdef HAVE__MEMCMP16
     /*
      * Use assembly version, which returns the difference between the
@@ -333,6 +390,18 @@ bool javaLangString_equals(u4 arg0, u4 arg1, u4 arg2, u4 arg3,
     /* quick length check */
     thisCount = dvmGetFieldInt((Object*) arg0, STRING_FIELDOFF_COUNT);
     compCount = dvmGetFieldInt((Object*) arg1, STRING_FIELDOFF_COUNT);
+
+    Thread* self = dvmThreadSelf();
+    CHECK_STACK_NATIVE(self);
+
+    Object* thisObj = (Object*)arg0;
+    LOG_READ(OBJ_JNI, arg0,STRING_FIELDOFF_COUNT, thisObj->clazz->objectSize);
+    Object* thatObj = (Object*)arg1;
+    LOG_READ(OBJ_JNI, arg1,STRING_FIELDOFF_COUNT, thatObj->clazz->objectSize);
+
+//    LOG_READ(OBJ_JNI, arg0,0, thisObj->clazz->objectSize);
+//    LOG_READ(OBJ_JNI, arg1,0, thatObj->clazz->objectSize);
+
     if (thisCount != compCount) {
         pResult->i = false;
         return true;
@@ -355,13 +424,36 @@ bool javaLangString_equals(u4 arg0, u4 arg1, u4 arg2, u4 arg3,
 
     thisOffset = dvmGetFieldInt((Object*) arg0, STRING_FIELDOFF_OFFSET);
     compOffset = dvmGetFieldInt((Object*) arg1, STRING_FIELDOFF_OFFSET);
+
+    LOG_READ(OBJ_JNI, arg0,STRING_FIELDOFF_OFFSET, thisObj->clazz->objectSize);
+    LOG_READ(OBJ_JNI, arg1,STRING_FIELDOFF_OFFSET, thatObj->clazz->objectSize);
+
     thisArray = (ArrayObject*)
         dvmGetFieldObject((Object*) arg0, STRING_FIELDOFF_VALUE);
     compArray = (ArrayObject*)
         dvmGetFieldObject((Object*) arg1, STRING_FIELDOFF_VALUE);
+
+    LOG_READ(OBJ_JNI, arg0,STRING_FIELDOFF_VALUE, thisObj->clazz->objectSize);
+    LOG_READ(OBJ_JNI, arg1,STRING_FIELDOFF_VALUE, thatObj->clazz->objectSize);
+    
     thisChars = ((const u2*)(void*)thisArray->contents) + thisOffset;
     compChars = ((const u2*)(void*)compArray->contents) + compOffset;
 
+    u4 thisAddr = (u4)thisArray;
+    u4 thatAddr = (u4)compArray;
+
+   // int itemp;
+
+   // for(itemp = 0; itemp < thisCount; itemp++){
+   // 	LOG_READ(OBJ_JNI_ARRAY, thisAddr,(thisOffset+itemp)*sizeof(u2), dvmArrayObjectSize(thisArray));	
+   // 	LOG_READ(OBJ_JNI_ARRAY, thatAddr,(compOffset+itemp)*sizeof(u2), dvmArrayObjectSize(compArray));	
+   //     if(thisChars[itemp] != compChars[itemp])
+   //     	break;
+   // }
+
+    LOG_READ(OBJ_ARRAY_ALL, thisAddr, 0, dvmArrayObjectSize(thisArray));	
+    LOG_READ(OBJ_ARRAY_ALL, thatAddr, 0, dvmArrayObjectSize(compArray));	
+
 #ifdef HAVE__MEMCMP16
     pResult->i = (__memcmp16(thisChars, compChars, thisCount) == 0);
 # ifdef CHECK_MEMCMP16
@@ -412,6 +504,12 @@ bool javaLangString_length(u4 arg0, u4 arg1, u4 arg2, u4 arg3,
     }
 
     pResult->i = dvmGetFieldInt((Object*) arg0, STRING_FIELDOFF_COUNT);
+
+    Thread* self = dvmThreadSelf();
+    CHECK_STACK_NATIVE(self);
+    Object* obj = (Object*)arg0;
+    LOG_READ(OBJ_JNI, arg0, STRING_FIELDOFF_COUNT, obj->clazz->objectSize);
+
     return true;
 }
 
@@ -430,6 +528,12 @@ bool javaLangString_isEmpty(u4 arg0, u4 arg1, u4 arg2, u4 arg3,
     }
 
     pResult->i = (dvmGetFieldInt((Object*) arg0, STRING_FIELDOFF_COUNT) == 0);
+
+    Thread* self = dvmThreadSelf();
+    CHECK_STACK_NATIVE(self);
+    Object* obj = (Object*)arg0;
+    LOG_READ(OBJ_JNI, arg0, STRING_FIELDOFF_COUNT, obj->clazz->objectSize);
+
     return true;
 }
 
@@ -455,6 +559,21 @@ static inline int indexOfCommon(Object* strObj, int ch, int start)
     const u2* chars = (const u2*)(void*)charArray->contents;
     int offset = dvmGetFieldInt(strObj, STRING_FIELDOFF_OFFSET);
     int count = dvmGetFieldInt(strObj, STRING_FIELDOFF_COUNT);
+
+    u4 strAddr = (u4)strObj;
+    Thread* self = dvmThreadSelf();
+    CHECK_STACK_NATIVE(self);
+    LOG_READ(OBJ_JNI, strAddr, STRING_FIELDOFF_VALUE, strObj->clazz->objectSize);
+    LOG_READ(OBJ_JNI, strAddr, STRING_FIELDOFF_OFFSET, strObj->clazz->objectSize);
+    LOG_READ(OBJ_JNI, strAddr, STRING_FIELDOFF_COUNT, strObj->clazz->objectSize);
+//    LOG_READ(OBJ_JNI, strAddr, 0, strObj->clazz->objectSize);
+
+
+    u4 thisAddr = (u4)charArray;
+
+//    LOG_READ(OBJ_JNI, thisAddr,0, dvmArrayObjectSize(charArray));	
+
+
     //ALOGI("String.indexOf(0x%08x, 0x%04x, %d) off=%d count=%d",
     //    (u4) strObj, ch, start, offset, count);
 
@@ -466,6 +585,16 @@ static inline int indexOfCommon(Object* strObj, int ch, int start)
     else if (start > count)
         start = count;
 
+//    int itemp;
+//
+//    for(itemp = start; itemp < count; itemp++){
+//	    LOG_READ(OBJ_JNI_ARRAY, thisAddr,(offset+itemp)*sizeof(u2), dvmArrayObjectSize(charArray));	
+//	    if(chars[itemp] == ch)
+//		    break;
+//    }
+
+    LOG_READ(OBJ_ARRAY_ALL, thisAddr, 0, dvmArrayObjectSize(charArray));	
+
 #if 0
     /* 16-bit loop, simple */
     while (start < count) {
diff --git a/vm/Jni.cpp b/vm/Jni.cpp
index b196eca..aede739 100644
--- a/vm/Jni.cpp
+++ b/vm/Jni.cpp
@@ -22,6 +22,7 @@
 #include "Misc.h"
 #include "ScopedPthreadMutexLock.h"
 #include "UniquePtr.h"
+#include "Common.h"
 
 #include <stdlib.h>
 #include <stdarg.h>
@@ -600,6 +601,10 @@ static void pinPrimitiveArray(ArrayObject* arrayObj) {
         ReportJniError();
     }
 
+    Thread* self = dvmThreadSelf();				    
+    CHECK_STACK_NATIVE(self);
+    LOG_READ(OBJ_JNI_HOLD_ARRAY, (uint32_t)(arrayObj),0, dvmArrayObjectSize(arrayObj));
+
     /*
      * If we're watching global ref usage, also keep an eye on these.
      *
@@ -641,6 +646,11 @@ static void unpinPrimitiveArray(ArrayObject* arrayObj) {
             arrayObj, dvmIsHeapAddress((Object*) arrayObj));
         return;
     }
+
+    Thread* self = dvmThreadSelf();				    
+    CHECK_STACK_NATIVE(self);
+    LOG_READ(OBJ_JNI_REL_ARRAY, (uint32_t)(arrayObj),0, dvmArrayObjectSize(arrayObj));	
+
 }
 
 /*
@@ -739,6 +749,7 @@ void dvmHookPlatformInvoke(void* pEnv, void* clazz, int argInfo, int argc,
 }
 #endif
 
+
 /*
  * Register a method that uses JNI calling conventions.
  */
@@ -1198,10 +1209,19 @@ void dvmCallJNIMethod(const u4* args, JValue* pResult, const Method* method, Thr
             (void*)method->insns, pResult);
     else
 #endif
-    dvmPlatformInvoke(env,
-            (ClassObject*) staticMethodClass,
-            method->jniArgInfo, method->insSize, modArgs, method->shorty,
-            (void*) method->insns, pResult);
+	    //Modified for tracing jni. Potential place to call java from native.
+	    if(!gDvm.isInstrSetupComplete||
+			    !isMethInstrumented(method))
+		    dvmPlatformInvoke(env,
+				    (ClassObject*) staticMethodClass,
+				    method->jniArgInfo, method->insSize, modArgs, method->shorty,
+				    (void*) method->insns, pResult);
+	    else
+		    jniBoundaryBridgeInMagicXZ89(self->instrCount, env,
+				    (ClassObject*) staticMethodClass,
+				    method->jniArgInfo, method->insSize, modArgs, method->shorty,
+				    (void*) method->insns, pResult);
+
     CHECK_STACK_SUM(self);
 
     dvmChangeStatus(self, oldStatus);
@@ -1803,6 +1823,7 @@ static jfieldID GetStaticFieldID(JNIEnv* env, jclass jclazz, const char* name, c
         ScopedJniThreadState ts(env);                                       \
         StaticField* sfield = (StaticField*) fieldID;                       \
         _ctype value;                                                       \
+	u4 sfAddr = (u4)sfield;\
         if (dvmIsVolatileField(sfield)) {                                   \
             if (_isref) {   /* only when _ctype==jobject */                 \
                 Object* obj = dvmGetStaticFieldObjectVolatile(sfield);      \
@@ -1818,6 +1839,9 @@ static jfieldID GetStaticFieldID(JNIEnv* env, jclass jclazz, const char* name, c
                 value = (_ctype) dvmGetStaticField##_jname(sfield);         \
             }                                                               \
         }                                                                   \
+	    Thread* self = ts.self();					    \
+	    CHECK_STACK_NATIVE(self);\
+	    LOG_READ(OBJ_JNI_STATIC,sfAddr,0, sizeof(_ctype));\
         return value;                                                       \
     }
 GET_STATIC_TYPE_FIELD(jobject, Object, true);
@@ -1840,6 +1864,7 @@ GET_STATIC_TYPE_FIELD(jdouble, Double, false);
         UNUSED_PARAMETER(jclazz);                                           \
         ScopedJniThreadState ts(env);                                       \
         StaticField* sfield = (StaticField*) fieldID;                       \
+	u4 sfAddr = (u4)sfield;\
         if (dvmIsVolatileField(sfield)) {                                   \
             if (_isref) {   /* only when _ctype==jobject */                 \
                 Object* valObj = dvmDecodeIndirectRef(ts.self(), (jobject)(u4)value); \
@@ -1855,6 +1880,8 @@ GET_STATIC_TYPE_FIELD(jdouble, Double, false);
                 dvmSetStaticField##_jname(sfield, (_ctype2)value);          \
             }                                                               \
         }                                                                   \
+	    Thread* self = ts.self(); \
+	    LOG_WRITE(OBJ_JNI_STATIC,sfAddr,0, sizeof(_ctype));\
     }
 SET_STATIC_TYPE_FIELD(jobject, Object*, Object, true);
 SET_STATIC_TYPE_FIELD(jboolean, bool, Boolean, false);
@@ -1896,6 +1923,9 @@ SET_STATIC_TYPE_FIELD(jdouble, double, Double, false);
                 value = (_ctype) dvmGetField##_jname(obj, field->byteOffset);\
             }                                                               \
         }                                                                   \
+	Thread* self = ts.self();					    \
+	CHECK_STACK_NATIVE(self);\
+	LOG_READ(OBJ_JNI,(uint32_t)(jobj), field->byteOffset, obj->clazz->objectSize); 	    \
         return value;                                                       \
     }
 GET_TYPE_FIELD(jobject, Object, true);
@@ -1935,6 +1965,8 @@ GET_TYPE_FIELD(jdouble, Double, false);
                     field->byteOffset, (_ctype2)value);                     \
             }                                                               \
         }                                                                   \
+	Thread* self = ts.self();                                           \
+	LOG_WRITE(OBJ_JNI, (uint32_t)(jobj), field->byteOffset, obj->clazz->objectSize);	    \
     }
 SET_TYPE_FIELD(jobject, Object*, Object, true);
 SET_TYPE_FIELD(jboolean, bool, Boolean, false);
@@ -2162,6 +2194,9 @@ static jstring NewString(JNIEnv* env, const jchar* unicodeChars, jsize len) {
 static jsize GetStringLength(JNIEnv* env, jstring jstr) {
     ScopedJniThreadState ts(env);
     StringObject* strObj = (StringObject*) dvmDecodeIndirectRef(ts.self(), jstr);
+    Thread* self = ((JNIEnvExt*)env)->self;				    
+    CHECK_STACK_NATIVE(self);
+    LOG_READ(OBJ_JNI, (uint32_t)(strObj),STRING_FIELDOFF_COUNT,strObj->clazz->objectSize);	
     return strObj->length();
 }
 
@@ -2178,6 +2213,10 @@ static const jchar* GetStringChars(JNIEnv* env, jstring jstr, jboolean* isCopy)
     StringObject* strObj = (StringObject*) dvmDecodeIndirectRef(ts.self(), jstr);
     ArrayObject* strChars = strObj->array();
 
+    Thread* self = ((JNIEnvExt*)env)->self;				    
+    CHECK_STACK_NATIVE(self);
+    LOG_READ(OBJ_JNI, (uint32_t)(strObj),STRING_FIELDOFF_VALUE,strObj->clazz->objectSize);	
+
     pinPrimitiveArray(strChars);
 
     const u2* data = strObj->chars();
@@ -2273,6 +2312,9 @@ static void ReleaseStringUTFChars(JNIEnv* env, jstring jstr, const char* utf) {
 static jsize GetArrayLength(JNIEnv* env, jarray jarr) {
     ScopedJniThreadState ts(env);
     ArrayObject* arrObj = (ArrayObject*) dvmDecodeIndirectRef(ts.self(), jarr);
+    Thread* self = ((JNIEnvExt*)env)->self;				    
+    CHECK_STACK_NATIVE(self);
+    LOG_READ(OBJ_JNI, (uint32_t)(arrObj),OFFSETOF_MEMBER(ArrayObject,length), dvmArrayObjectSize(arrObj));		
     return arrObj->length;
 }
 
@@ -2313,6 +2355,10 @@ static jobjectArray NewObjectArray(JNIEnv* env, jsize length,
     return newArray;
 }
 
+
+/*
+ *Xin: seems not public avaiable in Jni.h?
+ */
 static bool checkArrayElementBounds(ArrayObject* arrayObj, jsize index) {
     assert(arrayObj != NULL);
     if (index < 0 || index >= (int) arrayObj->length) {
@@ -2335,6 +2381,12 @@ static jobject GetObjectArrayElement(JNIEnv* env, jobjectArray jarr, jsize index
         return NULL;
     }
 
+    Thread* self = ((JNIEnvExt*)env)->self;			
+
+    CHECK_STACK_NATIVE(self);
+
+    LOG_READ(OBJ_JNI_ARRAY, (u4)arrayObj, index*sizeof(Object*), dvmArrayObjectSize(arrayObj));
+
     Object* value = ((Object**) (void*) arrayObj->contents)[index];
     return addLocalReference(ts.self(), value);
 }
@@ -2359,6 +2411,13 @@ static void SetObjectArrayElement(JNIEnv* env, jobjectArray jarr, jsize index, j
       dvmThrowArrayStoreExceptionIncompatibleElement(obj->clazz, arrayObj->clazz);
       return;
     }
+    
+    Thread* self = ((JNIEnvExt*)env)->self;			
+
+    CHECK_STACK_NATIVE(self);
+
+    LOG_WRITE(OBJ_JNI_ARRAY, (u4)arrayObj, index*sizeof(Object*), dvmArrayObjectSize(arrayObj));
+
 
     //ALOGV("JNI: set element %d in array %p to %p", index, array, value);
 
@@ -2375,9 +2434,11 @@ static void SetObjectArrayElement(JNIEnv* env, jobjectArray jarr, jsize index, j
         if (arrayObj == NULL) { \
             return NULL; \
         } \
+/*	Thread* self = ts.self();                                           \
+ *	LOG_ALLOC((uint32_t)arrayObj, gDvm.allocSize);	*/		    \
         _artype result = (_artype) addLocalReference(ts.self(), (Object*) arrayObj); \
         dvmReleaseTrackedAlloc((Object*) arrayObj, NULL); \
-        return result; \
+	return result; \
     }
 NEW_PRIMITIVE_ARRAY(jbooleanArray, Boolean, 'Z');
 NEW_PRIMITIVE_ARRAY(jbyteArray, Byte, 'B');
@@ -2403,7 +2464,7 @@ NEW_PRIMITIVE_ARRAY(jdoubleArray, Double, 'D');
     { \
         ScopedJniThreadState ts(env); \
         ArrayObject* arrayObj = (ArrayObject*) dvmDecodeIndirectRef(ts.self(), jarr); \
-        pinPrimitiveArray(arrayObj); \
+	pinPrimitiveArray(arrayObj); \
         _ctype* data = (_ctype*) (void*) arrayObj->contents; \
         if (isCopy != NULL) { \
             *isCopy = JNI_FALSE; \
@@ -2448,7 +2509,10 @@ static void throwArrayRegionOutOfBounds(ArrayObject* arrayObj, jsize start,
     { \
         ScopedJniThreadState ts(env); \
         ArrayObject* arrayObj = (ArrayObject*) dvmDecodeIndirectRef(ts.self(), jarr); \
-        _ctype* data = (_ctype*) (void*) arrayObj->contents; \
+        Thread* self = ((JNIEnvExt*)env)->self;				    \
+	CHECK_STACK_NATIVE(self);\
+	LOG_READ(OBJ_ARRAY_ALL, (uint32_t)(arrayObj), 0, dvmArrayObjectSize(arrayObj));	    \
+	_ctype* data = (_ctype*) (void*) arrayObj->contents; \
         if (start < 0 || len < 0 || start + len > (int) arrayObj->length) { \
             throwArrayRegionOutOfBounds(arrayObj, start, len, "src"); \
         } else { \
@@ -2465,6 +2529,8 @@ static void throwArrayRegionOutOfBounds(ArrayObject* arrayObj, jsize start,
     { \
         ScopedJniThreadState ts(env); \
         ArrayObject* arrayObj = (ArrayObject*) dvmDecodeIndirectRef(ts.self(), jarr); \
+        Thread* self = ((JNIEnvExt*)env)->self;				    \
+	LOG_WRITE(OBJ_ARRAY_ALL, (uint32_t)(arrayObj),0, dvmArrayObjectSize(arrayObj));	    \
         _ctype* data = (_ctype*) (void*) arrayObj->contents; \
         if (start < 0 || len < 0 || start + len > (int) arrayObj->length) { \
             throwArrayRegionOutOfBounds(arrayObj, start, len, "dst"); \
@@ -2519,6 +2585,7 @@ static jint RegisterNatives(JNIEnv* env, jclass jclazz,
         {
             return JNI_ERR;
         }
+	LOG_NATIVELIBCALL(clazz, methods[i]);
     }
     return JNI_OK;
 }
@@ -2614,6 +2681,15 @@ static void GetStringRegion(JNIEnv* env, jstring jstr, jsize start, jsize len, j
         dvmThrowStringIndexOutOfBoundsExceptionWithRegion(strLen, start, len);
         return;
     }
+	
+    Thread* self = ((JNIEnvExt*)env)->self;				    
+    CHECK_STACK_NATIVE(self);
+    LOG_READ(OBJ_JNI, (uint32_t)(strObj),STRING_FIELDOFF_VALUE,strObj->clazz->objectSize);	
+
+    ArrayObject* arrObj = strObj->array();
+    u4 arrAddr = (u4)arrObj;
+    LOG_READ(OBJ_JNI, arrAddr,0, dvmArrayObjectSize(arrObj));	
+
     memcpy(buf, strObj->chars() + start, len * sizeof(u2));
 }
 
@@ -2629,6 +2705,15 @@ static void GetStringUTFRegion(JNIEnv* env, jstring jstr, jsize start, jsize len
         dvmThrowStringIndexOutOfBoundsExceptionWithRegion(strLen, start, len);
         return;
     }
+
+    Thread* self = ((JNIEnvExt*)env)->self;				    
+    CHECK_STACK_NATIVE(self);
+    LOG_READ(OBJ_JNI, (uint32_t)(strObj),STRING_FIELDOFF_VALUE,strObj->clazz->objectSize);	
+
+    ArrayObject* arrObj = strObj->array();
+    u4 arrAddr = (u4)arrObj;
+    LOG_READ(OBJ_JNI, arrAddr,0, dvmArrayObjectSize(arrObj));	
+
     dvmGetStringUtfRegion(strObj, start, len, buf);
 }
 
@@ -2671,6 +2756,10 @@ static const jchar* GetStringCritical(JNIEnv* env, jstring jstr, jboolean* isCop
     StringObject* strObj = (StringObject*) dvmDecodeIndirectRef(ts.self(), jstr);
     ArrayObject* strChars = strObj->array();
 
+    Thread* self = ((JNIEnvExt*)env)->self;				    
+    CHECK_STACK_NATIVE(self);
+    LOG_READ(OBJ_JNI, (uint32_t)(strObj),STRING_FIELDOFF_VALUE,strObj->clazz->objectSize);	
+
     pinPrimitiveArray(strChars);
 
     const u2* data = strObj->chars();
diff --git a/vm/Native.cpp b/vm/Native.cpp
index fe51158..f1daccd 100644
--- a/vm/Native.cpp
+++ b/vm/Native.cpp
@@ -29,6 +29,7 @@
 static void freeSharedLibEntry(void* ptr);
 static void* lookupSharedLibMethod(const Method* method);
 
+ 
 #ifdef WITH_HOUDINI
 /*
  * Pointer to hold Houdini Hook structure defined in libhoudini_hook.a
@@ -49,6 +50,7 @@ const char* dvmGetMethodShorty(void* method)
     return meth->shorty;
 }
 #endif
+ 
 
 /*
  * Initialize the native code loader.
@@ -123,7 +125,13 @@ void dvmResolveNativeMethod(const u4* args, JValue* pResult,
         }
         DalvikBridgeFunc dfunc = (DalvikBridgeFunc) infunc;
         dvmSetNativeFunc((Method*) method, dfunc, NULL);
-        dfunc(args, pResult, method, self);
+	//Modified for tracing jni. Potential place to call java from native.
+	if(gDvm.isInstrSetupComplete &&
+			isMethInstrumented(method)
+			)
+		jniBoundaryNonBridgeInMagicXZ89(self->instrCount, dfunc, args, pResult, method, self);
+	else
+		dfunc(args, pResult, method, self);
         return;
     }
 
@@ -234,7 +242,7 @@ static SharedLib* findSharedLibEntry(const char* pathName)
 static SharedLib* addSharedLibEntry(SharedLib* pLib)
 {
     u4 hash = dvmComputeUtf8Hash(pLib->pathName);
-
+    LOG_NATIVELIB(pLib->pathName);
     /*
      * Do the lookup with the "add" flag set.  If we add it, we will get
      * our own pointer back.  If somebody beat us to the punch, we'll get
@@ -445,7 +453,6 @@ bool dvmLoadNativeCode(const char* pathName, Object* classLoader,
         bool result = true;
         void* vonLoad;
         int version;
-
 #ifdef WITH_HOUDINI
         vonLoad = houdini::hookDlsym(useHoudini, handle, "JNI_OnLoad");
 #else
@@ -470,7 +477,7 @@ bool dvmLoadNativeCode(const char* pathName, Object* classLoader,
                 ALOGI("[Calling JNI_OnLoad for \"%s\"]", pathName);
             }
 #ifdef WITH_HOUDINI
-            version = houdini::hookJniOnload(useHoudini, (void*)func, (void*)gDvmJni.jniVm, NULL);
+	    version = houdini::hookJniOnload(useHoudini, (void*)func, (void*)gDvmJni.jniVm, NULL);
 #else
             version = (*func)(gDvmJni.jniVm, NULL);
 #endif
@@ -741,11 +748,9 @@ static int findMethodInLib(void* vlib, void* vmethod)
         return 0;
     } else
         ALOGV("+++ scanning '%s' for '%s'", pLib->pathName, meth->name);
-
 #ifdef WITH_HOUDINI
     dvmSetHoudiniMethod((Method*)vmethod, pLib->useHoudini);
 #endif
-
     /*
      * First, we try it without the signature.
      */
@@ -787,6 +792,8 @@ static int findMethodInLib(void* vlib, void* vmethod)
         }
     } else {
         ALOGV("Found '%s' with dlsym", mangleCM);
+	//LOG_NATIVELIBCALL(meth->clazz->descriptor, meth->name,
+        //    		meth->shorty,pLib->pathName);
     }
 
 bail:
diff --git a/vm/ReconfigureDvm.mk b/vm/ReconfigureDvm.mk
index 5405f3e..df1e34d 100644
--- a/vm/ReconfigureDvm.mk
+++ b/vm/ReconfigureDvm.mk
@@ -26,9 +26,10 @@ endif
 
 include $(LOCAL_PATH)/Dvm.mk
 
-ifeq ($(INTEL_HOUDINI),true)
-    LOCAL_CFLAGS += -DWITH_HOUDINI
-endif
+#I don't know how houdini interacts with JNI, so it is disabled for now.
+#ifeq ($(INTEL_HOUDINI),true)
+#    LOCAL_CFLAGS += -DWITH_HOUDINI
+#endif
 
 LOCAL_SHARED_LIBRARIES += \
 	libcorkscrew \
@@ -41,9 +42,9 @@ LOCAL_SHARED_LIBRARIES += \
 
 LOCAL_STATIC_LIBRARIES += libdex
 
-ifeq ($(INTEL_HOUDINI),true)
-    LOCAL_STATIC_LIBRARIES += libhoudini_hook
-endif
+#ifeq ($(INTEL_HOUDINI),true)
+#    LOCAL_STATIC_LIBRARIES += libhoudini_hook
+#endif
 
 LOCAL_C_INCLUDES += external/stlport/stlport bionic/ bionic/libstdc++/include
 LOCAL_SHARED_LIBRARIES += libstlport
diff --git a/vm/SignalCatcher.cpp b/vm/SignalCatcher.cpp
index d4302aa..f4e97d3 100644
--- a/vm/SignalCatcher.cpp
+++ b/vm/SignalCatcher.cpp
@@ -248,6 +248,24 @@ static void handleSigUsr2()
 }
 #endif
 
+/**
+ * Added for printing running time or instruction counts of each thread.
+ */
+static void handleSigInt()
+{
+	LOGX("TraceDebug: Handling INT signal.");
+	LOGX("TraceDebug: isSetup %s, feaure: %d", (gDvm.isInstrSetupComplete?"true":"false"), gDvm.feature);
+#ifdef XIN_DEBUG
+	Thread* self = dvmThreadSelf();
+#endif
+	LOGX("TraceDebug: Current thread id: %u", self->threadId);
+	if(gDvm.isInstrSetupComplete ){
+		if(FEATURE_COUNT == gDvm.feature || FEATURE_TIME == gDvm.feature || FEATURE_PIN_TIME == gDvm.feature){
+			gDvm.isBoundHit = true;
+		}
+	}
+}
+
 /*
  * Sleep in sigwait() until a signal arrives.
  */
@@ -265,8 +283,11 @@ static void* signalCatcherThreadStart(void* arg)
     sigemptyset(&mask);
     sigaddset(&mask, SIGQUIT);
     sigaddset(&mask, SIGUSR1);
+    //added for MCC
+    sigaddset(&mask, SIGINT);
 #if defined(WITH_JIT) && defined(WITH_JIT_TUNING)
     sigaddset(&mask, SIGUSR2);
+    ALOGI("JIT TUNING ENABLED");
 #endif
 
     while (true) {
@@ -316,6 +337,10 @@ loop:
             handleSigUsr2();
             break;
 #endif
+	case SIGINT:
+	    handleSigInt();
+	    break;
+	    
         default:
             ALOGE("unexpected signal %d", rcvd);
             break;
diff --git a/vm/Thread.cpp b/vm/Thread.cpp
index 9671b84..f1e1e4d 100644
--- a/vm/Thread.cpp
+++ b/vm/Thread.cpp
@@ -1537,7 +1537,11 @@ static void* interpThreadStart(void* arg)
 
     ALOGV("threadid=%d: calling run()", self->threadId);
     assert(strcmp(run->name, "run") == 0);
+
+
     dvmCallMethod(self, run, self->threadObj, &unused);
+
+
     ALOGV("threadid=%d: exiting", self->threadId);
 
     /*
@@ -2854,9 +2858,9 @@ static bool fullSuspendCheck(Thread* self)
     bool needSuspend = (self->suspendCount != 0);
     if (needSuspend) {
         LOG_THREAD("threadid=%d: self-suspending", self->threadId);
+
         ThreadStatus oldStatus = self->status;      /* should be RUNNING */
         self->status = THREAD_SUSPENDED;
-
         ATRACE_BEGIN("DVM Suspend");
         while (self->suspendCount != 0) {
             /*
diff --git a/vm/Thread.h b/vm/Thread.h
index 8deef6e..7c20d23 100644
--- a/vm/Thread.h
+++ b/vm/Thread.h
@@ -25,6 +25,9 @@
 
 #include <errno.h>
 #include <cutils/sched_policy.h>
+#include <vector>
+
+#define DEF_STACK_DEP 100
 
 #if defined(CHECK_MUTEX) && !defined(__USE_UNIX98)
 /* glibc lacks this unless you #define __USE_UNIX98 */
@@ -307,6 +310,21 @@ struct Thread {
 #if defined(ARCH_IA32) && defined(WITH_JIT)
     u4 spillRegion[MAX_SPILL_JIT_IA];
 #endif
+
+    //For time logging
+    bool isLogDone;
+
+    u4 instrCount;
+    u4 methodCount;
+
+    //Stack for trace fixing
+    std::vector<Method*> stack;
+    Method* topMethod;
+    bool isInFix;
+    u4 interpTotalTime; //Total amount of time spent in interpretation
+    u4 interpStartTime; //Last time entering interpretation code
+    bool hasStarted;
+    u4 startTime;
 };
 
 /* start point for an internal thread; mimics pthread args */
diff --git a/vm/alloc/Alloc.cpp b/vm/alloc/Alloc.cpp
index cfcb968..e28af32 100644
--- a/vm/alloc/Alloc.cpp
+++ b/vm/alloc/Alloc.cpp
@@ -192,6 +192,14 @@ Object* dvmAllocObject(ClassObject* clazz, int flags)
         dvmTrackAllocation(clazz, clazz->objectSize);   /* notify DDMS */
     }
 
+
+    /*Xin: Ideally, we shouldn't insert the allocation log
+     * in this file as it might include noise from the jvm.
+     * But it is always safe to include more allocations.*/
+
+    Thread* self = dvmThreadSelf();
+    LOG_ALLOC_MCC((u4) newObj, clazz->objectSize);
+
     return newObj;
 }
 
diff --git a/vm/interp/Interp.cpp b/vm/interp/Interp.cpp
index fa77523..37c1127 100644
--- a/vm/interp/Interp.cpp
+++ b/vm/interp/Interp.cpp
@@ -644,6 +644,7 @@ void dvmReportExceptionThrow(Thread* self, Object* exception)
  */
 void dvmReportInvoke(Thread* self, const Method* methodToCall)
 {
+    //logMethodEntrance(self);
     TRACE_METHOD_ENTER(self, methodToCall);
 }
 
@@ -656,6 +657,7 @@ void dvmReportInvoke(Thread* self, const Method* methodToCall)
  */
 void dvmReportPreNativeInvoke(const Method* methodToCall, Thread* self, u4* fp)
 {
+
 #if defined(WITH_JIT)
     /*
      * Actively building a trace?  If so, end it now.   The trace
@@ -679,14 +681,15 @@ void dvmReportPreNativeInvoke(const Method* methodToCall, Thread* self, u4* fp)
  */
 void dvmReportPostNativeInvoke(const Method* methodToCall, Thread* self, u4* fp)
 {
-    if (self->interpBreak.ctl.subMode & kSubModeDebuggerActive) {
-        Object* thisPtr = dvmGetThisPtr(self->interpSave.method, fp);
-        assert(thisPtr == NULL || dvmIsHeapAddress(thisPtr));
-        dvmDbgPostLocationEvent(methodToCall, -1, thisPtr, DBG_METHOD_EXIT);
-    }
-    if (self->interpBreak.ctl.subMode & kSubModeMethodTrace) {
-        dvmFastNativeMethodTraceExit(methodToCall, self);
-    }
+
+	if (self->interpBreak.ctl.subMode & kSubModeDebuggerActive) {
+		Object* thisPtr = dvmGetThisPtr(self->interpSave.method, fp);
+		assert(thisPtr == NULL || dvmIsHeapAddress(thisPtr));
+		dvmDbgPostLocationEvent(methodToCall, -1, thisPtr, DBG_METHOD_EXIT);
+	}
+	if (self->interpBreak.ctl.subMode & kSubModeMethodTrace) {
+		dvmFastNativeMethodTraceExit(methodToCall, self);
+	}
 }
 
 /*
@@ -1870,6 +1873,7 @@ void dvmCheckBefore(const u2 *pc, u4 *fp, Thread* self)
  */
 void dvmInterpret(Thread* self, const Method* method, JValue* pResult)
 {
+
     InterpSaveState interpSaveState;
     ExecutionSubModes savedSubModes;
 
@@ -1924,6 +1928,13 @@ void dvmInterpret(Thread* self, const Method* method, JValue* pResult)
     self->interpSave.curFrame = (u4*) self->interpSave.curFrame;
     self->interpSave.pc = method->insns;
 
+    if(gDvm.feature == FEATURE_TRACE || gDvm.feature == FEATURE_TIME || gDvm.feature == FEATURE_TRACE_TIME){
+	    if(gDvm.isInstrSetupComplete &&  !gDvm.compare && !gDvm.stopLogging) { 
+		    if(!CHECK_STACK_SIZE(self))
+			    FIX_STACK(self);
+	    }
+    }
+
     assert(!dvmIsNativeMethod(method));
 
     /*
@@ -1954,7 +1965,6 @@ void dvmInterpret(Thread* self, const Method* method, JValue* pResult)
 
     // Call the interpreter
     (*stdInterp)(self);
-
     *pResult = self->interpSave.retval;
 
     /* Restore interpreter state from previous activation */
diff --git a/vm/interp/Stack.cpp b/vm/interp/Stack.cpp
index 1433f13..737de1a 100644
--- a/vm/interp/Stack.cpp
+++ b/vm/interp/Stack.cpp
@@ -511,7 +511,13 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
     }
 #endif
 
-    //dvmDumpThreadStack(dvmThreadSelf());
+    {
+	    LOG_WRITE_PARAM(method, ins, (u4)verifyCount);
+	    //dvmDumpThreadStack(dvmThreadSelf());
+	    LOG_METHOD_ENTRANCE((uint32_t)method, method->clazz->descriptor, method->name,
+			    method->shorty,dvmIsNativeMethod(method));   
+	    LOG_READ_PARAM(method, ins, (u4)verifyCount);
+    }
 
     if (dvmIsNativeMethod(method)) {
         TRACE_METHOD_ENTER(self, method);
@@ -523,13 +529,21 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
                               method, self);
         TRACE_METHOD_EXIT(self, method);
     } else {
-        dvmInterpret(self, method, pResult);
+	    //Modified for tracing jni. Potential place to call java from native.
+	    if(!gDvm.isInstrSetupComplete)
+		    dvmInterpret(self, method, pResult);
+	    else
+		    jniBoundaryOutMagicXZ89(self->instrCount, self,method,pResult);
     }
 
+
 #ifndef NDEBUG
 bail:
 #endif
     dvmPopFrame(self);
+    LOG_WRITE_RET(method, pResult->j);
+    LOG_METHOD_EXIT_WITH_CHECK((uint32_t)method);   
+    LOG_READ_RET(method, pResult->j);
 }
 
 /*
@@ -618,6 +632,12 @@ void dvmCallMethodA(Thread* self, const Method* method, Object* obj,
     }
 #endif
 
+    {
+	    LOG_WRITE_PARAM(method,ins,(u4)verifyCount);
+	    LOG_METHOD_ENTRANCE((uint32_t)method, method->clazz->descriptor, method->name,
+			    method->shorty,dvmIsNativeMethod(method));     
+	    LOG_READ_PARAM(method,ins,(u4)verifyCount);
+    }
     if (dvmIsNativeMethod(method)) {
         TRACE_METHOD_ENTER(self, method);
         /*
@@ -628,11 +648,20 @@ void dvmCallMethodA(Thread* self, const Method* method, Object* obj,
                               method, self);
         TRACE_METHOD_EXIT(self, method);
     } else {
-        dvmInterpret(self, method, pResult);
+	    //Modified for tracing jni. Potential place to call java from native.
+	    if(!gDvm.isInstrSetupComplete)
+		    dvmInterpret(self, method, pResult);
+	    else
+		    jniBoundaryOutMagicXZ89(self->instrCount, self,method,pResult);
     }
 
+
 bail:
     dvmPopFrame(self);
+
+    LOG_WRITE_RET(method, pResult->j);
+    LOG_METHOD_EXIT_WITH_CHECK((uint32_t)method);
+    LOG_READ_RET(method, pResult->j);
 }
 
 static void throwArgumentTypeMismatch(int argIndex, ClassObject* expected, DataObject* arg) {
@@ -724,6 +753,13 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
     }
 #endif
 
+    {
+	    LOG_WRITE_PARAM(method, (u4*)ins,(u4)verifyCount);
+	    LOG_METHOD_ENTRANCE((uint32_t)method, method->clazz->descriptor, method->name,
+			    method->shorty,dvmIsNativeMethod(method));     
+	    LOG_READ_PARAM(method, (u4*)ins, (u4)verifyCount);
+    }
+
     if (dvmIsNativeMethod(method)) {
         TRACE_METHOD_ENTER(self, method);
         /*
@@ -734,7 +770,11 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
                               method, self);
         TRACE_METHOD_EXIT(self, method);
     } else {
-        dvmInterpret(self, method, &retval);
+	    //Modified for tracing jni. Potential place to call java from native.
+	    if(!gDvm.isInstrSetupComplete)
+		    dvmInterpret(self, method, &retval);
+	    else
+		    jniBoundaryOutMagicXZ89(self->instrCount, self,method,&retval);
     }
 
     /*
@@ -744,6 +784,10 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
     dvmPopFrame(self);
     needPop = false;
 
+    LOG_WRITE_RET(method, retval.j);
+    LOG_METHOD_EXIT_WITH_CHECK((uint32_t)method);     
+    LOG_READ_RET(method, retval.j);
+
     /*
      * If an exception is raised, wrap and replace.  This is necessary
      * because the invoked method could have thrown a checked exception
@@ -771,6 +815,7 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
 bail:
     if (needPop) {
         dvmPopFrame(self);
+    	LOG_METHOD_EXIT_WITH_CHECK((uint32_t)method);     
     }
     return retObj;
 }
diff --git a/vm/mterp/c/OP_NEW_ARRAY.cpp b/vm/mterp/c/OP_NEW_ARRAY.cpp
index 6d6771a..4965b49 100644
--- a/vm/mterp/c/OP_NEW_ARRAY.cpp
+++ b/vm/mterp/c/OP_NEW_ARRAY.cpp
@@ -27,9 +27,12 @@ HANDLE_OPCODE(OP_NEW_ARRAY /*vA, vB, class@CCCC*/)
         assert(dvmIsClassInitialized(arrayClass));
 
         newArray = dvmAllocArrayByClass(arrayClass, length, ALLOC_DONT_TRACK);
+/*	u4 objAddr = (u4)newArray; */
         if (newArray == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newArray);
+/*	u4 objSize = dvmArrayObjectSize(newArray);*/
+/*	LOG_ALLOC(objAddr,objSize); */
     }
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_NEW_INSTANCE.cpp b/vm/mterp/c/OP_NEW_INSTANCE.cpp
index b0b9c18..18aa674 100644
--- a/vm/mterp/c/OP_NEW_INSTANCE.cpp
+++ b/vm/mterp/c/OP_NEW_INSTANCE.cpp
@@ -43,6 +43,7 @@ HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)
         if (newObj == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newObj);
+//	LOG_ALLOC((u4) newObj, clazz->objectSize);
     }
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_SGET.cpp b/vm/mterp/c/OP_SGET.cpp
index 5297cd7..4c12865 100644
--- a/vm/mterp/c/OP_SGET.cpp
+++ b/vm/mterp/c/OP_SGET.cpp
@@ -1,2 +1,2 @@
-HANDLE_SGET_X(OP_SGET,                  "", Int, )
+HANDLE_SGET_X(OP_SGET,                  "", Int, 4,)
 OP_END
diff --git a/vm/mterp/c/OP_SGET_BOOLEAN.cpp b/vm/mterp/c/OP_SGET_BOOLEAN.cpp
index 7c5d45e..9f981ae 100644
--- a/vm/mterp/c/OP_SGET_BOOLEAN.cpp
+++ b/vm/mterp/c/OP_SGET_BOOLEAN.cpp
@@ -1,2 +1,2 @@
-HANDLE_SGET_X(OP_SGET_BOOLEAN,          "", Int, )
+HANDLE_SGET_X(OP_SGET_BOOLEAN,          "", Int,1, )
 OP_END
diff --git a/vm/mterp/c/OP_SGET_BYTE.cpp b/vm/mterp/c/OP_SGET_BYTE.cpp
index b37cab4..3888113 100644
--- a/vm/mterp/c/OP_SGET_BYTE.cpp
+++ b/vm/mterp/c/OP_SGET_BYTE.cpp
@@ -1,2 +1,2 @@
-HANDLE_SGET_X(OP_SGET_BYTE,             "", Int, )
+HANDLE_SGET_X(OP_SGET_BYTE,             "", Int, 1,)
 OP_END
diff --git a/vm/mterp/c/OP_SGET_CHAR.cpp b/vm/mterp/c/OP_SGET_CHAR.cpp
index 7ede5ec..ddb4864 100644
--- a/vm/mterp/c/OP_SGET_CHAR.cpp
+++ b/vm/mterp/c/OP_SGET_CHAR.cpp
@@ -1,2 +1,2 @@
-HANDLE_SGET_X(OP_SGET_CHAR,             "", Int, )
+HANDLE_SGET_X(OP_SGET_CHAR,             "", Int, 2,)
 OP_END
diff --git a/vm/mterp/c/OP_SGET_OBJECT.cpp b/vm/mterp/c/OP_SGET_OBJECT.cpp
index 9f3b63d..04d9a0a 100644
--- a/vm/mterp/c/OP_SGET_OBJECT.cpp
+++ b/vm/mterp/c/OP_SGET_OBJECT.cpp
@@ -1,2 +1,2 @@
-HANDLE_SGET_X(OP_SGET_OBJECT,           "-object", Object, _AS_OBJECT)
+HANDLE_SGET_X(OP_SGET_OBJECT,           "-object", Object,4, _AS_OBJECT)
 OP_END
diff --git a/vm/mterp/c/OP_SGET_OBJECT_VOLATILE.cpp b/vm/mterp/c/OP_SGET_OBJECT_VOLATILE.cpp
index 0a9049f..4a4038f 100644
--- a/vm/mterp/c/OP_SGET_OBJECT_VOLATILE.cpp
+++ b/vm/mterp/c/OP_SGET_OBJECT_VOLATILE.cpp
@@ -1,2 +1,2 @@
-HANDLE_SGET_X(OP_SGET_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, _AS_OBJECT)
+HANDLE_SGET_X(OP_SGET_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, 4, _AS_OBJECT)
 OP_END
diff --git a/vm/mterp/c/OP_SGET_SHORT.cpp b/vm/mterp/c/OP_SGET_SHORT.cpp
index cd1fe4c..28d74d4 100644
--- a/vm/mterp/c/OP_SGET_SHORT.cpp
+++ b/vm/mterp/c/OP_SGET_SHORT.cpp
@@ -1,2 +1,2 @@
-HANDLE_SGET_X(OP_SGET_SHORT,            "", Int, )
+HANDLE_SGET_X(OP_SGET_SHORT,            "", Int,2, )
 OP_END
diff --git a/vm/mterp/c/OP_SGET_VOLATILE.cpp b/vm/mterp/c/OP_SGET_VOLATILE.cpp
index 6713a54..efe3857 100644
--- a/vm/mterp/c/OP_SGET_VOLATILE.cpp
+++ b/vm/mterp/c/OP_SGET_VOLATILE.cpp
@@ -1,2 +1,2 @@
-HANDLE_SGET_X(OP_SGET_VOLATILE,         "-volatile", IntVolatile, )
+HANDLE_SGET_X(OP_SGET_VOLATILE,         "-volatile", IntVolatile, 4,)
 OP_END
diff --git a/vm/mterp/c/OP_SGET_WIDE.cpp b/vm/mterp/c/OP_SGET_WIDE.cpp
index 817c6e7..3bf6e8d 100644
--- a/vm/mterp/c/OP_SGET_WIDE.cpp
+++ b/vm/mterp/c/OP_SGET_WIDE.cpp
@@ -1,2 +1,2 @@
-HANDLE_SGET_X(OP_SGET_WIDE,             "-wide", Long, _WIDE)
+HANDLE_SGET_X(OP_SGET_WIDE,             "-wide", Long, 8, _WIDE)
 OP_END
diff --git a/vm/mterp/c/OP_SGET_WIDE_VOLATILE.cpp b/vm/mterp/c/OP_SGET_WIDE_VOLATILE.cpp
index 26a67bf..01683ee 100644
--- a/vm/mterp/c/OP_SGET_WIDE_VOLATILE.cpp
+++ b/vm/mterp/c/OP_SGET_WIDE_VOLATILE.cpp
@@ -1,2 +1,2 @@
-HANDLE_SGET_X(OP_SGET_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, _WIDE)
+HANDLE_SGET_X(OP_SGET_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, 8, _WIDE)
 OP_END
diff --git a/vm/mterp/c/OP_SPUT.cpp b/vm/mterp/c/OP_SPUT.cpp
index 286e64c..c0c7eb7 100644
--- a/vm/mterp/c/OP_SPUT.cpp
+++ b/vm/mterp/c/OP_SPUT.cpp
@@ -1,2 +1,2 @@
-HANDLE_SPUT_X(OP_SPUT,                  "", Int, )
+HANDLE_SPUT_X(OP_SPUT,                  "", Int, 4, )
 OP_END
diff --git a/vm/mterp/c/OP_SPUT_BOOLEAN.cpp b/vm/mterp/c/OP_SPUT_BOOLEAN.cpp
index 55ceb11..a49e3a2 100644
--- a/vm/mterp/c/OP_SPUT_BOOLEAN.cpp
+++ b/vm/mterp/c/OP_SPUT_BOOLEAN.cpp
@@ -1,2 +1,2 @@
-HANDLE_SPUT_X(OP_SPUT_BOOLEAN,          "", Int, )
+HANDLE_SPUT_X(OP_SPUT_BOOLEAN,          "", Int,1, )
 OP_END
diff --git a/vm/mterp/c/OP_SPUT_BYTE.cpp b/vm/mterp/c/OP_SPUT_BYTE.cpp
index d242fe1..2a3ca4c 100644
--- a/vm/mterp/c/OP_SPUT_BYTE.cpp
+++ b/vm/mterp/c/OP_SPUT_BYTE.cpp
@@ -1,2 +1,2 @@
-HANDLE_SPUT_X(OP_SPUT_BYTE,             "", Int, )
+HANDLE_SPUT_X(OP_SPUT_BYTE,             "", Int, 1, )
 OP_END
diff --git a/vm/mterp/c/OP_SPUT_CHAR.cpp b/vm/mterp/c/OP_SPUT_CHAR.cpp
index 18a2f06..4e27795 100644
--- a/vm/mterp/c/OP_SPUT_CHAR.cpp
+++ b/vm/mterp/c/OP_SPUT_CHAR.cpp
@@ -1,2 +1,2 @@
-HANDLE_SPUT_X(OP_SPUT_CHAR,             "", Int, )
+HANDLE_SPUT_X(OP_SPUT_CHAR,             "", Int, 2, )
 OP_END
diff --git a/vm/mterp/c/OP_SPUT_OBJECT.cpp b/vm/mterp/c/OP_SPUT_OBJECT.cpp
index fb223d6..06e0c3a 100644
--- a/vm/mterp/c/OP_SPUT_OBJECT.cpp
+++ b/vm/mterp/c/OP_SPUT_OBJECT.cpp
@@ -1,2 +1,2 @@
-HANDLE_SPUT_X(OP_SPUT_OBJECT,           "-object", Object, _AS_OBJECT)
+HANDLE_SPUT_X(OP_SPUT_OBJECT,           "-object", Object, 4, _AS_OBJECT)
 OP_END
diff --git a/vm/mterp/c/OP_SPUT_OBJECT_VOLATILE.cpp b/vm/mterp/c/OP_SPUT_OBJECT_VOLATILE.cpp
index 38d6c0d..3bc123f 100644
--- a/vm/mterp/c/OP_SPUT_OBJECT_VOLATILE.cpp
+++ b/vm/mterp/c/OP_SPUT_OBJECT_VOLATILE.cpp
@@ -1,2 +1,2 @@
-HANDLE_SPUT_X(OP_SPUT_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, _AS_OBJECT)
+HANDLE_SPUT_X(OP_SPUT_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, 4, _AS_OBJECT)
 OP_END
diff --git a/vm/mterp/c/OP_SPUT_SHORT.cpp b/vm/mterp/c/OP_SPUT_SHORT.cpp
index c6cd8d6..5301bf7 100644
--- a/vm/mterp/c/OP_SPUT_SHORT.cpp
+++ b/vm/mterp/c/OP_SPUT_SHORT.cpp
@@ -1,2 +1,2 @@
-HANDLE_SPUT_X(OP_SPUT_SHORT,            "", Int, )
+HANDLE_SPUT_X(OP_SPUT_SHORT,            "", Int, 2, )
 OP_END
diff --git a/vm/mterp/c/OP_SPUT_VOLATILE.cpp b/vm/mterp/c/OP_SPUT_VOLATILE.cpp
index 7899d05..e457e1c 100644
--- a/vm/mterp/c/OP_SPUT_VOLATILE.cpp
+++ b/vm/mterp/c/OP_SPUT_VOLATILE.cpp
@@ -1,2 +1,2 @@
-HANDLE_SPUT_X(OP_SPUT_VOLATILE,         "-volatile", IntVolatile, )
+HANDLE_SPUT_X(OP_SPUT_VOLATILE,         "-volatile", IntVolatile, 4, )
 OP_END
diff --git a/vm/mterp/c/OP_SPUT_WIDE.cpp b/vm/mterp/c/OP_SPUT_WIDE.cpp
index 0c74651..431e96e 100644
--- a/vm/mterp/c/OP_SPUT_WIDE.cpp
+++ b/vm/mterp/c/OP_SPUT_WIDE.cpp
@@ -1,2 +1,2 @@
-HANDLE_SPUT_X(OP_SPUT_WIDE,             "-wide", Long, _WIDE)
+HANDLE_SPUT_X(OP_SPUT_WIDE,             "-wide", Long, 8, _WIDE)
 OP_END
diff --git a/vm/mterp/c/OP_SPUT_WIDE_VOLATILE.cpp b/vm/mterp/c/OP_SPUT_WIDE_VOLATILE.cpp
index bdf552c..50903d4 100644
--- a/vm/mterp/c/OP_SPUT_WIDE_VOLATILE.cpp
+++ b/vm/mterp/c/OP_SPUT_WIDE_VOLATILE.cpp
@@ -1,2 +1,2 @@
-HANDLE_SPUT_X(OP_SPUT_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, _WIDE)
+HANDLE_SPUT_X(OP_SPUT_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, 8, _WIDE)
 OP_END
diff --git a/vm/mterp/c/gotoTargets.cpp b/vm/mterp/c/gotoTargets.cpp
index 452bee8..b31fd66 100644
--- a/vm/mterp/c/gotoTargets.cpp
+++ b/vm/mterp/c/gotoTargets.cpp
@@ -565,12 +565,19 @@ GOTO_TARGET(returnFromMethod)
             GOTO_bail();
         }
 
+	uint32_t maddr = (uint32_t)curMethod;
+
         /* update thread FP, and reset local variables */
         self->interpSave.curFrame = fp;
         curMethod = SAVEAREA_FROM_FP(fp)->method;
         self->interpSave.method = curMethod;
-        //methodClass = curMethod->clazz;
+	//methodClass = curMethod->clazz;
         methodClassDex = curMethod->clazz->pDvmDex;
+
+	LOG_WRITE_RET(curMethod, retval.j);
+	LOG_METHOD_EXIT_WITH_CHECK(maddr);
+	LOG_READ_RET(curMethod, retval.j);
+
         pc = saveArea->savedPc;
         ILOGD("> (return to %s.%s %s)", curMethod->clazz->descriptor,
             curMethod->name, curMethod->shorty);
@@ -765,8 +772,12 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
         //printf(" --> %s.%s %s\n", methodToCall->clazz->descriptor,
         //    methodToCall->name, methodToCall->shorty);
 
+//	LOG_METHOD_ENTRANCE((uint32_t)methodToCall, methodToCall->clazz->descriptor, methodToCall->name,
+//			    methodToCall->shorty,dvmIsNativeMethod(methodToCall));
+	
         u4* outs;
         int i;
+	u4 argc;
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -776,6 +787,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             // so few args it won't matter much
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
+	    argc = vsrc1;
             outs = OUTS_FROM_FP(fp, vsrc1);
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
@@ -787,6 +799,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(count <= 5);
 
             outs = OUTS_FROM_FP(fp, count);
+	    argc = count;
 #if 0
             if (count == 5) {
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -816,6 +829,12 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             }
 #endif
         }
+	{
+		LOG_WRITE_PARAM(methodToCall, outs, argc);
+		LOG_METHOD_ENTRANCE((uint32_t)methodToCall, methodToCall->clazz->descriptor, methodToCall->name,
+				methodToCall->shorty,dvmIsNativeMethod(methodToCall));
+		LOG_READ_PARAM(methodToCall,outs,argc);
+	}
     }
 
     /*
@@ -900,6 +919,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             pc = methodToCall->insns;
             fp = newFp;
             self->interpSave.curFrame = fp;
+	            
 #ifdef EASY_GDB
             debugSaveArea = SAVEAREA_FROM_FP(newFp);
 #endif
@@ -914,6 +934,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
             self->interpSave.curFrame = newFp;
 
+
             DUMP_REGS(methodToCall, newFp, true);   // show input args
 
             if (self->interpBreak.ctl.subMode != 0) {
@@ -923,12 +944,27 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             ILOGD("> native <-- %s.%s %s", methodToCall->clazz->descriptor,
                   methodToCall->name, methodToCall->shorty);
 
+
             /*
              * Jump through native call bridge.  Because we leave no
              * space for locals on native calls, "newFp" points directly
              * to the method arguments.
              */
-            (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+       //     (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+
+	    if(!gDvm.isInstrSetupComplete ||
+			    methodToCall->nativeFunc == dvmResolveNativeMethod ||
+			    methodToCall->nativeFunc == proxyInvoker ||
+			    methodToCall->nativeFunc == proxyConstructor ||
+			    methodToCall->nativeFunc == (DalvikBridgeFunc)dvmAbstractMethodStub ||
+			    methodToCall->nativeFunc == dvmCheckCallJNIMethod ||
+			    methodToCall->nativeFunc == dvmCallJNIMethod ||
+			    !isMethInstrumented(methodToCall)
+			    )
+		    (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+	    else{
+		    jniBoundaryNonBridgeInMagicXZ89(self->instrCount, methodToCall->nativeFunc, newFp, &retval, methodToCall, self);
+	    }
 
             if (self->interpBreak.ctl.subMode != 0) {
                 dvmReportPostNativeInvoke(methodToCall, self, newSaveArea->prevFrame);
@@ -939,16 +975,28 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             self->interpSave.curFrame = newSaveArea->prevFrame;
             fp = newSaveArea->prevFrame;
 
+	    bool isExceptionThrown = dvmCheckException(self);
+
+
+	    if(!isExceptionThrown){
+		    LOG_WRITE_RET(methodToCall, retval.j);
+	    }
+	    LOG_METHOD_EXIT_WITH_CHECK((uint32_t)methodToCall);
+	    if(!isExceptionThrown){
+		    LOG_READ_RET(methodToCall, retval.j);
+	    }
+
             /*
              * If the native code threw an exception, or interpreted code
              * invoked by the native call threw one and nobody has cleared
              * it, jump to our local exception handling.
              */
-            if (dvmCheckException(self)) {
+ //           if (dvmCheckException(self)) {
+	    if(isExceptionThrown){
                 ALOGV("Exception thrown by/below native code");
                 GOTO_exceptionThrown();
-            }
-
+             } 
+		
             ILOGD("> retval=0x%llx (leaving native)", retval.j);
             ILOGD("> (return from native %s.%s to %s.%s %s)",
                 methodToCall->clazz->descriptor, methodToCall->name,
diff --git a/vm/mterp/c/opcommon.cpp b/vm/mterp/c/opcommon.cpp
index a49ed86..dd45a61 100644
--- a/vm/mterp/c/opcommon.cpp
+++ b/vm/mterp/c/opcommon.cpp
@@ -448,7 +448,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;    /* array ptr */                        \
         vsrc2 = arrayInfo >> 8;      /* index */                            \
         ILOGV("|aget%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -459,6 +462,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)]);      \
         ILOGV("+ AGET[%d]=%#x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));   \
+	LOG_READ(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -473,7 +477,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;   /* BB: array ptr */                     \
         vsrc2 = arrayInfo >> 8;     /* CC: index */                         \
         ILOGV("|aput%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -484,6 +491,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)] =          \
             GET_REGISTER##_regsize(vdst);                                   \
+        LOG_WRITE(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -514,7 +522,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iget%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -527,6 +536,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             dvmGetField##_ftype(obj, ifield->byteOffset));                  \
         ILOGV("+ IGET '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -539,12 +549,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iget%s-quick v%d,v%d,field@+%u",                            \
             (_opname), vdst, vsrc1, ref);                                   \
+	u4 objAddr = GET_REGISTER(vsrc1);            \
         obj = (Object*) GET_REGISTER(vsrc1);                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ref,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -558,7 +570,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iput%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1);  \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -571,6 +584,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             GET_REGISTER##_regsize(vdst));                                  \
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -583,12 +597,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iput%s-quick v%d,v%d,field@0x%04x",                         \
             (_opname), vdst, vsrc1, ref);                                   \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ref, obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -600,7 +616,7 @@ GOTO_TARGET_DECL(exceptionThrown);
  * This is controlled by the JIT_STUB_HACK maco.
  */
 
-#define HANDLE_SGET_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SGET_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -617,13 +633,15 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         SET_REGISTER##_regsize(vdst, dvmGetStaticField##_ftype(sfield));    \
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_READ(OBJ_STATIC,sfAddr,0, _fsize);\
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -640,8 +658,10 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         dvmSetStaticField##_ftype(sfield, GET_REGISTER##_regsize(vdst));    \
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_WRITE(OBJ_STATIC,sfAddr,0,_fsize);\
     }                                                                       \
     FINISH(2);
diff --git a/vm/mterp/out/InterpC-allstubs.cpp b/vm/mterp/out/InterpC-allstubs.cpp
index 1ef8783..0243033 100644
--- a/vm/mterp/out/InterpC-allstubs.cpp
+++ b/vm/mterp/out/InterpC-allstubs.cpp
@@ -964,7 +964,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;    /* array ptr */                        \
         vsrc2 = arrayInfo >> 8;      /* index */                            \
         ILOGV("|aget%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -975,6 +978,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)]);      \
         ILOGV("+ AGET[%d]=%#x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));   \
+	LOG_READ(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -989,7 +993,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;   /* BB: array ptr */                     \
         vsrc2 = arrayInfo >> 8;     /* CC: index */                         \
         ILOGV("|aput%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -1000,6 +1007,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)] =          \
             GET_REGISTER##_regsize(vdst);                                   \
+        LOG_WRITE(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1030,7 +1038,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iget%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1043,6 +1052,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             dvmGetField##_ftype(obj, ifield->byteOffset));                  \
         ILOGV("+ IGET '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1055,12 +1065,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iget%s-quick v%d,v%d,field@+%u",                            \
             (_opname), vdst, vsrc1, ref);                                   \
+	u4 objAddr = GET_REGISTER(vsrc1);            \
         obj = (Object*) GET_REGISTER(vsrc1);                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ref,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1074,7 +1086,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iput%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1);  \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1087,6 +1100,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             GET_REGISTER##_regsize(vdst));                                  \
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1099,12 +1113,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iput%s-quick v%d,v%d,field@0x%04x",                         \
             (_opname), vdst, vsrc1, ref);                                   \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ref, obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1116,7 +1132,7 @@ GOTO_TARGET_DECL(exceptionThrown);
  * This is controlled by the JIT_STUB_HACK maco.
  */
 
-#define HANDLE_SGET_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SGET_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1133,13 +1149,15 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         SET_REGISTER##_regsize(vdst, dvmGetStaticField##_ftype(sfield));    \
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_READ(OBJ_STATIC,sfAddr,0, _fsize);\
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1156,9 +1174,11 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         dvmSetStaticField##_ftype(sfield, GET_REGISTER##_regsize(vdst));    \
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_WRITE(OBJ_STATIC,sfAddr,0,_fsize);\
     }                                                                       \
     FINISH(2);
 
@@ -1681,6 +1701,7 @@ HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)
         if (newObj == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newObj);
+//	LOG_ALLOC((u4) newObj, clazz->objectSize);
     }
     FINISH(2);
 OP_END
@@ -1715,9 +1736,12 @@ HANDLE_OPCODE(OP_NEW_ARRAY /*vA, vB, class@CCCC*/)
         assert(dvmIsClassInitialized(arrayClass));
 
         newArray = dvmAllocArrayByClass(arrayClass, length, ALLOC_DONT_TRACK);
+/*	u4 objAddr = (u4)newArray; */
         if (newArray == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newArray);
+/*	u4 objSize = dvmArrayObjectSize(newArray);*/
+/*	LOG_ALLOC(objAddr,objSize); */
     }
     FINISH(2);
 OP_END
@@ -2147,59 +2171,59 @@ HANDLE_IPUT_X(OP_IPUT_SHORT,            "", Int, )
 OP_END
 
 /* File: c/OP_SGET.cpp */
-HANDLE_SGET_X(OP_SGET,                  "", Int, )
+HANDLE_SGET_X(OP_SGET,                  "", Int, 4,)
 OP_END
 
 /* File: c/OP_SGET_WIDE.cpp */
-HANDLE_SGET_X(OP_SGET_WIDE,             "-wide", Long, _WIDE)
+HANDLE_SGET_X(OP_SGET_WIDE,             "-wide", Long, 8, _WIDE)
 OP_END
 
 /* File: c/OP_SGET_OBJECT.cpp */
-HANDLE_SGET_X(OP_SGET_OBJECT,           "-object", Object, _AS_OBJECT)
+HANDLE_SGET_X(OP_SGET_OBJECT,           "-object", Object,4, _AS_OBJECT)
 OP_END
 
 /* File: c/OP_SGET_BOOLEAN.cpp */
-HANDLE_SGET_X(OP_SGET_BOOLEAN,          "", Int, )
+HANDLE_SGET_X(OP_SGET_BOOLEAN,          "", Int,1, )
 OP_END
 
 /* File: c/OP_SGET_BYTE.cpp */
-HANDLE_SGET_X(OP_SGET_BYTE,             "", Int, )
+HANDLE_SGET_X(OP_SGET_BYTE,             "", Int, 1,)
 OP_END
 
 /* File: c/OP_SGET_CHAR.cpp */
-HANDLE_SGET_X(OP_SGET_CHAR,             "", Int, )
+HANDLE_SGET_X(OP_SGET_CHAR,             "", Int, 2,)
 OP_END
 
 /* File: c/OP_SGET_SHORT.cpp */
-HANDLE_SGET_X(OP_SGET_SHORT,            "", Int, )
+HANDLE_SGET_X(OP_SGET_SHORT,            "", Int,2, )
 OP_END
 
 /* File: c/OP_SPUT.cpp */
-HANDLE_SPUT_X(OP_SPUT,                  "", Int, )
+HANDLE_SPUT_X(OP_SPUT,                  "", Int, 4, )
 OP_END
 
 /* File: c/OP_SPUT_WIDE.cpp */
-HANDLE_SPUT_X(OP_SPUT_WIDE,             "-wide", Long, _WIDE)
+HANDLE_SPUT_X(OP_SPUT_WIDE,             "-wide", Long, 8, _WIDE)
 OP_END
 
 /* File: c/OP_SPUT_OBJECT.cpp */
-HANDLE_SPUT_X(OP_SPUT_OBJECT,           "-object", Object, _AS_OBJECT)
+HANDLE_SPUT_X(OP_SPUT_OBJECT,           "-object", Object, 4, _AS_OBJECT)
 OP_END
 
 /* File: c/OP_SPUT_BOOLEAN.cpp */
-HANDLE_SPUT_X(OP_SPUT_BOOLEAN,          "", Int, )
+HANDLE_SPUT_X(OP_SPUT_BOOLEAN,          "", Int,1, )
 OP_END
 
 /* File: c/OP_SPUT_BYTE.cpp */
-HANDLE_SPUT_X(OP_SPUT_BYTE,             "", Int, )
+HANDLE_SPUT_X(OP_SPUT_BYTE,             "", Int, 1, )
 OP_END
 
 /* File: c/OP_SPUT_CHAR.cpp */
-HANDLE_SPUT_X(OP_SPUT_CHAR,             "", Int, )
+HANDLE_SPUT_X(OP_SPUT_CHAR,             "", Int, 2, )
 OP_END
 
 /* File: c/OP_SPUT_SHORT.cpp */
-HANDLE_SPUT_X(OP_SPUT_SHORT,            "", Int, )
+HANDLE_SPUT_X(OP_SPUT_SHORT,            "", Int, 2, )
 OP_END
 
 /* File: c/OP_INVOKE_VIRTUAL.cpp */
@@ -2745,11 +2769,11 @@ HANDLE_IPUT_X(OP_IPUT_VOLATILE,         "-volatile", IntVolatile, )
 OP_END
 
 /* File: c/OP_SGET_VOLATILE.cpp */
-HANDLE_SGET_X(OP_SGET_VOLATILE,         "-volatile", IntVolatile, )
+HANDLE_SGET_X(OP_SGET_VOLATILE,         "-volatile", IntVolatile, 4,)
 OP_END
 
 /* File: c/OP_SPUT_VOLATILE.cpp */
-HANDLE_SPUT_X(OP_SPUT_VOLATILE,         "-volatile", IntVolatile, )
+HANDLE_SPUT_X(OP_SPUT_VOLATILE,         "-volatile", IntVolatile, 4, )
 OP_END
 
 /* File: c/OP_IGET_OBJECT_VOLATILE.cpp */
@@ -2765,11 +2789,11 @@ HANDLE_IPUT_X(OP_IPUT_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, _WIDE)
 OP_END
 
 /* File: c/OP_SGET_WIDE_VOLATILE.cpp */
-HANDLE_SGET_X(OP_SGET_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, _WIDE)
+HANDLE_SGET_X(OP_SGET_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, 8, _WIDE)
 OP_END
 
 /* File: c/OP_SPUT_WIDE_VOLATILE.cpp */
-HANDLE_SPUT_X(OP_SPUT_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, _WIDE)
+HANDLE_SPUT_X(OP_SPUT_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, 8, _WIDE)
 OP_END
 
 /* File: c/OP_BREAKPOINT.cpp */
@@ -3003,11 +3027,11 @@ HANDLE_IPUT_X(OP_IPUT_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, _AS_
 OP_END
 
 /* File: c/OP_SGET_OBJECT_VOLATILE.cpp */
-HANDLE_SGET_X(OP_SGET_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, _AS_OBJECT)
+HANDLE_SGET_X(OP_SGET_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, 4, _AS_OBJECT)
 OP_END
 
 /* File: c/OP_SPUT_OBJECT_VOLATILE.cpp */
-HANDLE_SPUT_X(OP_SPUT_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, _AS_OBJECT)
+HANDLE_SPUT_X(OP_SPUT_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, 4, _AS_OBJECT)
 OP_END
 
 /* File: c/OP_UNUSED_FF.cpp */
@@ -3651,12 +3675,19 @@ GOTO_TARGET(returnFromMethod)
             GOTO_bail();
         }
 
+	uint32_t maddr = (uint32_t)curMethod;
+
         /* update thread FP, and reset local variables */
         self->interpSave.curFrame = fp;
         curMethod = SAVEAREA_FROM_FP(fp)->method;
         self->interpSave.method = curMethod;
-        //methodClass = curMethod->clazz;
+	//methodClass = curMethod->clazz;
         methodClassDex = curMethod->clazz->pDvmDex;
+
+	LOG_WRITE_RET(curMethod, retval.j);
+	LOG_METHOD_EXIT_WITH_CHECK(maddr);
+	LOG_READ_RET(curMethod, retval.j);
+
         pc = saveArea->savedPc;
         ILOGD("> (return to %s.%s %s)", curMethod->clazz->descriptor,
             curMethod->name, curMethod->shorty);
@@ -3851,8 +3882,12 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
         //printf(" --> %s.%s %s\n", methodToCall->clazz->descriptor,
         //    methodToCall->name, methodToCall->shorty);
 
+//	LOG_METHOD_ENTRANCE((uint32_t)methodToCall, methodToCall->clazz->descriptor, methodToCall->name,
+//			    methodToCall->shorty,dvmIsNativeMethod(methodToCall));
+	
         u4* outs;
         int i;
+	u4 argc;
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -3862,6 +3897,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             // so few args it won't matter much
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
+	    argc = vsrc1;
             outs = OUTS_FROM_FP(fp, vsrc1);
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
@@ -3873,6 +3909,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(count <= 5);
 
             outs = OUTS_FROM_FP(fp, count);
+	    argc = count;
 #if 0
             if (count == 5) {
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -3902,6 +3939,12 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             }
 #endif
         }
+	{
+		LOG_WRITE_PARAM(methodToCall, outs, argc);
+		LOG_METHOD_ENTRANCE((uint32_t)methodToCall, methodToCall->clazz->descriptor, methodToCall->name,
+				methodToCall->shorty,dvmIsNativeMethod(methodToCall));
+		LOG_READ_PARAM(methodToCall,outs,argc);
+	}
     }
 
     /*
@@ -3986,6 +4029,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             pc = methodToCall->insns;
             fp = newFp;
             self->interpSave.curFrame = fp;
+	            
 #ifdef EASY_GDB
             debugSaveArea = SAVEAREA_FROM_FP(newFp);
 #endif
@@ -4000,6 +4044,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
             self->interpSave.curFrame = newFp;
 
+
             DUMP_REGS(methodToCall, newFp, true);   // show input args
 
             if (self->interpBreak.ctl.subMode != 0) {
@@ -4009,12 +4054,27 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             ILOGD("> native <-- %s.%s %s", methodToCall->clazz->descriptor,
                   methodToCall->name, methodToCall->shorty);
 
+
             /*
              * Jump through native call bridge.  Because we leave no
              * space for locals on native calls, "newFp" points directly
              * to the method arguments.
              */
-            (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+       //     (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+
+	    if(!gDvm.isInstrSetupComplete ||
+			    methodToCall->nativeFunc == dvmResolveNativeMethod ||
+			    methodToCall->nativeFunc == proxyInvoker ||
+			    methodToCall->nativeFunc == proxyConstructor ||
+			    methodToCall->nativeFunc == (DalvikBridgeFunc)dvmAbstractMethodStub ||
+			    methodToCall->nativeFunc == dvmCheckCallJNIMethod ||
+			    methodToCall->nativeFunc == dvmCallJNIMethod ||
+			    !isMethInstrumented(methodToCall)
+			    )
+		    (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+	    else{
+		    jniBoundaryNonBridgeInMagicXZ89(self->instrCount, methodToCall->nativeFunc, newFp, &retval, methodToCall, self);
+	    }
 
             if (self->interpBreak.ctl.subMode != 0) {
                 dvmReportPostNativeInvoke(methodToCall, self, newSaveArea->prevFrame);
@@ -4025,16 +4085,28 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             self->interpSave.curFrame = newSaveArea->prevFrame;
             fp = newSaveArea->prevFrame;
 
+	    bool isExceptionThrown = dvmCheckException(self);
+
+
+	    if(!isExceptionThrown){
+		    LOG_WRITE_RET(methodToCall, retval.j);
+	    }
+	    LOG_METHOD_EXIT_WITH_CHECK((uint32_t)methodToCall);
+	    if(!isExceptionThrown){
+		    LOG_READ_RET(methodToCall, retval.j);
+	    }
+
             /*
              * If the native code threw an exception, or interpreted code
              * invoked by the native call threw one and nobody has cleared
              * it, jump to our local exception handling.
              */
-            if (dvmCheckException(self)) {
+ //           if (dvmCheckException(self)) {
+	    if(isExceptionThrown){
                 ALOGV("Exception thrown by/below native code");
                 GOTO_exceptionThrown();
-            }
-
+             } 
+		
             ILOGD("> retval=0x%llx (leaving native)", retval.j);
             ILOGD("> (return from native %s.%s to %s.%s %s)",
                 methodToCall->clazz->descriptor, methodToCall->name,
diff --git a/vm/mterp/out/InterpC-armv5te-vfp.cpp b/vm/mterp/out/InterpC-armv5te-vfp.cpp
index 9d6b458..97e2e6a 100644
--- a/vm/mterp/out/InterpC-armv5te-vfp.cpp
+++ b/vm/mterp/out/InterpC-armv5te-vfp.cpp
@@ -964,7 +964,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;    /* array ptr */                        \
         vsrc2 = arrayInfo >> 8;      /* index */                            \
         ILOGV("|aget%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -975,6 +978,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)]);      \
         ILOGV("+ AGET[%d]=%#x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));   \
+	LOG_READ(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -989,7 +993,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;   /* BB: array ptr */                     \
         vsrc2 = arrayInfo >> 8;     /* CC: index */                         \
         ILOGV("|aput%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -1000,6 +1007,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)] =          \
             GET_REGISTER##_regsize(vdst);                                   \
+        LOG_WRITE(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1030,7 +1038,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iget%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1043,6 +1052,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             dvmGetField##_ftype(obj, ifield->byteOffset));                  \
         ILOGV("+ IGET '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1055,12 +1065,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iget%s-quick v%d,v%d,field@+%u",                            \
             (_opname), vdst, vsrc1, ref);                                   \
+	u4 objAddr = GET_REGISTER(vsrc1);            \
         obj = (Object*) GET_REGISTER(vsrc1);                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ref,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1074,7 +1086,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iput%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1);  \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1087,6 +1100,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             GET_REGISTER##_regsize(vdst));                                  \
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1099,12 +1113,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iput%s-quick v%d,v%d,field@0x%04x",                         \
             (_opname), vdst, vsrc1, ref);                                   \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ref, obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1116,7 +1132,7 @@ GOTO_TARGET_DECL(exceptionThrown);
  * This is controlled by the JIT_STUB_HACK maco.
  */
 
-#define HANDLE_SGET_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SGET_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1133,13 +1149,15 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         SET_REGISTER##_regsize(vdst, dvmGetStaticField##_ftype(sfield));    \
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_READ(OBJ_STATIC,sfAddr,0, _fsize);\
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1156,9 +1174,11 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         dvmSetStaticField##_ftype(sfield, GET_REGISTER##_regsize(vdst));    \
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_WRITE(OBJ_STATIC,sfAddr,0,_fsize);\
     }                                                                       \
     FINISH(2);
 
diff --git a/vm/mterp/out/InterpC-armv5te.cpp b/vm/mterp/out/InterpC-armv5te.cpp
index 99831b1..70b52ac 100644
--- a/vm/mterp/out/InterpC-armv5te.cpp
+++ b/vm/mterp/out/InterpC-armv5te.cpp
@@ -964,7 +964,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;    /* array ptr */                        \
         vsrc2 = arrayInfo >> 8;      /* index */                            \
         ILOGV("|aget%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -975,6 +978,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)]);      \
         ILOGV("+ AGET[%d]=%#x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));   \
+	LOG_READ(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -989,7 +993,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;   /* BB: array ptr */                     \
         vsrc2 = arrayInfo >> 8;     /* CC: index */                         \
         ILOGV("|aput%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -1000,6 +1007,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)] =          \
             GET_REGISTER##_regsize(vdst);                                   \
+        LOG_WRITE(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1030,7 +1038,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iget%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1043,6 +1052,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             dvmGetField##_ftype(obj, ifield->byteOffset));                  \
         ILOGV("+ IGET '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1055,12 +1065,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iget%s-quick v%d,v%d,field@+%u",                            \
             (_opname), vdst, vsrc1, ref);                                   \
+	u4 objAddr = GET_REGISTER(vsrc1);            \
         obj = (Object*) GET_REGISTER(vsrc1);                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ref,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1074,7 +1086,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iput%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1);  \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1087,6 +1100,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             GET_REGISTER##_regsize(vdst));                                  \
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1099,12 +1113,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iput%s-quick v%d,v%d,field@0x%04x",                         \
             (_opname), vdst, vsrc1, ref);                                   \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ref, obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1116,7 +1132,7 @@ GOTO_TARGET_DECL(exceptionThrown);
  * This is controlled by the JIT_STUB_HACK maco.
  */
 
-#define HANDLE_SGET_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SGET_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1133,13 +1149,15 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         SET_REGISTER##_regsize(vdst, dvmGetStaticField##_ftype(sfield));    \
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_READ(OBJ_STATIC,sfAddr,0, _fsize);\
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1156,9 +1174,11 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         dvmSetStaticField##_ftype(sfield, GET_REGISTER##_regsize(vdst));    \
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_WRITE(OBJ_STATIC,sfAddr,0,_fsize);\
     }                                                                       \
     FINISH(2);
 
diff --git a/vm/mterp/out/InterpC-armv7-a-neon.cpp b/vm/mterp/out/InterpC-armv7-a-neon.cpp
index 7a3434c..5f3496a 100644
--- a/vm/mterp/out/InterpC-armv7-a-neon.cpp
+++ b/vm/mterp/out/InterpC-armv7-a-neon.cpp
@@ -964,7 +964,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;    /* array ptr */                        \
         vsrc2 = arrayInfo >> 8;      /* index */                            \
         ILOGV("|aget%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -975,6 +978,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)]);      \
         ILOGV("+ AGET[%d]=%#x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));   \
+	LOG_READ(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -989,7 +993,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;   /* BB: array ptr */                     \
         vsrc2 = arrayInfo >> 8;     /* CC: index */                         \
         ILOGV("|aput%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -1000,6 +1007,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)] =          \
             GET_REGISTER##_regsize(vdst);                                   \
+        LOG_WRITE(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1030,7 +1038,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iget%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1043,6 +1052,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             dvmGetField##_ftype(obj, ifield->byteOffset));                  \
         ILOGV("+ IGET '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1055,12 +1065,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iget%s-quick v%d,v%d,field@+%u",                            \
             (_opname), vdst, vsrc1, ref);                                   \
+	u4 objAddr = GET_REGISTER(vsrc1);            \
         obj = (Object*) GET_REGISTER(vsrc1);                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ref,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1074,7 +1086,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iput%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1);  \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1087,6 +1100,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             GET_REGISTER##_regsize(vdst));                                  \
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1099,12 +1113,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iput%s-quick v%d,v%d,field@0x%04x",                         \
             (_opname), vdst, vsrc1, ref);                                   \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ref, obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1116,7 +1132,7 @@ GOTO_TARGET_DECL(exceptionThrown);
  * This is controlled by the JIT_STUB_HACK maco.
  */
 
-#define HANDLE_SGET_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SGET_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1133,13 +1149,15 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         SET_REGISTER##_regsize(vdst, dvmGetStaticField##_ftype(sfield));    \
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_READ(OBJ_STATIC,sfAddr,0, _fsize);\
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1156,9 +1174,11 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         dvmSetStaticField##_ftype(sfield, GET_REGISTER##_regsize(vdst));    \
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_WRITE(OBJ_STATIC,sfAddr,0,_fsize);\
     }                                                                       \
     FINISH(2);
 
diff --git a/vm/mterp/out/InterpC-armv7-a.cpp b/vm/mterp/out/InterpC-armv7-a.cpp
index 1dcfb68..4e33364 100644
--- a/vm/mterp/out/InterpC-armv7-a.cpp
+++ b/vm/mterp/out/InterpC-armv7-a.cpp
@@ -964,7 +964,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;    /* array ptr */                        \
         vsrc2 = arrayInfo >> 8;      /* index */                            \
         ILOGV("|aget%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -975,6 +978,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)]);      \
         ILOGV("+ AGET[%d]=%#x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));   \
+	LOG_READ(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -989,7 +993,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;   /* BB: array ptr */                     \
         vsrc2 = arrayInfo >> 8;     /* CC: index */                         \
         ILOGV("|aput%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -1000,6 +1007,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)] =          \
             GET_REGISTER##_regsize(vdst);                                   \
+        LOG_WRITE(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1030,7 +1038,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iget%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1043,6 +1052,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             dvmGetField##_ftype(obj, ifield->byteOffset));                  \
         ILOGV("+ IGET '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1055,12 +1065,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iget%s-quick v%d,v%d,field@+%u",                            \
             (_opname), vdst, vsrc1, ref);                                   \
+	u4 objAddr = GET_REGISTER(vsrc1);            \
         obj = (Object*) GET_REGISTER(vsrc1);                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ref,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1074,7 +1086,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iput%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1);  \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1087,6 +1100,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             GET_REGISTER##_regsize(vdst));                                  \
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1099,12 +1113,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iput%s-quick v%d,v%d,field@0x%04x",                         \
             (_opname), vdst, vsrc1, ref);                                   \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ref, obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1116,7 +1132,7 @@ GOTO_TARGET_DECL(exceptionThrown);
  * This is controlled by the JIT_STUB_HACK maco.
  */
 
-#define HANDLE_SGET_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SGET_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1133,13 +1149,15 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         SET_REGISTER##_regsize(vdst, dvmGetStaticField##_ftype(sfield));    \
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_READ(OBJ_STATIC,sfAddr,0, _fsize);\
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1156,9 +1174,11 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         dvmSetStaticField##_ftype(sfield, GET_REGISTER##_regsize(vdst));    \
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_WRITE(OBJ_STATIC,sfAddr,0,_fsize);\
     }                                                                       \
     FINISH(2);
 
diff --git a/vm/mterp/out/InterpC-mips.cpp b/vm/mterp/out/InterpC-mips.cpp
index 69260da..3577757 100644
--- a/vm/mterp/out/InterpC-mips.cpp
+++ b/vm/mterp/out/InterpC-mips.cpp
@@ -964,7 +964,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;    /* array ptr */                        \
         vsrc2 = arrayInfo >> 8;      /* index */                            \
         ILOGV("|aget%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -975,6 +978,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)]);      \
         ILOGV("+ AGET[%d]=%#x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));   \
+	LOG_READ(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -989,7 +993,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;   /* BB: array ptr */                     \
         vsrc2 = arrayInfo >> 8;     /* CC: index */                         \
         ILOGV("|aput%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -1000,6 +1007,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)] =          \
             GET_REGISTER##_regsize(vdst);                                   \
+        LOG_WRITE(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1030,7 +1038,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iget%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1043,6 +1052,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             dvmGetField##_ftype(obj, ifield->byteOffset));                  \
         ILOGV("+ IGET '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1055,12 +1065,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iget%s-quick v%d,v%d,field@+%u",                            \
             (_opname), vdst, vsrc1, ref);                                   \
+	u4 objAddr = GET_REGISTER(vsrc1);            \
         obj = (Object*) GET_REGISTER(vsrc1);                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ref,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1074,7 +1086,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iput%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1);  \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1087,6 +1100,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             GET_REGISTER##_regsize(vdst));                                  \
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1099,12 +1113,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iput%s-quick v%d,v%d,field@0x%04x",                         \
             (_opname), vdst, vsrc1, ref);                                   \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ref, obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1116,7 +1132,7 @@ GOTO_TARGET_DECL(exceptionThrown);
  * This is controlled by the JIT_STUB_HACK maco.
  */
 
-#define HANDLE_SGET_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SGET_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1133,13 +1149,15 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         SET_REGISTER##_regsize(vdst, dvmGetStaticField##_ftype(sfield));    \
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_READ(OBJ_STATIC,sfAddr,0, _fsize);\
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1156,9 +1174,11 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         dvmSetStaticField##_ftype(sfield, GET_REGISTER##_regsize(vdst));    \
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_WRITE(OBJ_STATIC,sfAddr,0,_fsize);\
     }                                                                       \
     FINISH(2);
 
@@ -1756,12 +1776,19 @@ GOTO_TARGET(returnFromMethod)
             GOTO_bail();
         }
 
+	uint32_t maddr = (uint32_t)curMethod;
+
         /* update thread FP, and reset local variables */
         self->interpSave.curFrame = fp;
         curMethod = SAVEAREA_FROM_FP(fp)->method;
         self->interpSave.method = curMethod;
-        //methodClass = curMethod->clazz;
+	//methodClass = curMethod->clazz;
         methodClassDex = curMethod->clazz->pDvmDex;
+
+	LOG_WRITE_RET(curMethod, retval.j);
+	LOG_METHOD_EXIT_WITH_CHECK(maddr);
+	LOG_READ_RET(curMethod, retval.j);
+
         pc = saveArea->savedPc;
         ILOGD("> (return to %s.%s %s)", curMethod->clazz->descriptor,
             curMethod->name, curMethod->shorty);
@@ -1956,8 +1983,12 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
         //printf(" --> %s.%s %s\n", methodToCall->clazz->descriptor,
         //    methodToCall->name, methodToCall->shorty);
 
+//	LOG_METHOD_ENTRANCE((uint32_t)methodToCall, methodToCall->clazz->descriptor, methodToCall->name,
+//			    methodToCall->shorty,dvmIsNativeMethod(methodToCall));
+	
         u4* outs;
         int i;
+	u4 argc;
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -1967,6 +1998,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             // so few args it won't matter much
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
+	    argc = vsrc1;
             outs = OUTS_FROM_FP(fp, vsrc1);
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
@@ -1978,6 +2010,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(count <= 5);
 
             outs = OUTS_FROM_FP(fp, count);
+	    argc = count;
 #if 0
             if (count == 5) {
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -2007,6 +2040,12 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             }
 #endif
         }
+	{
+		LOG_WRITE_PARAM(methodToCall, outs, argc);
+		LOG_METHOD_ENTRANCE((uint32_t)methodToCall, methodToCall->clazz->descriptor, methodToCall->name,
+				methodToCall->shorty,dvmIsNativeMethod(methodToCall));
+		LOG_READ_PARAM(methodToCall,outs,argc);
+	}
     }
 
     /*
@@ -2091,6 +2130,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             pc = methodToCall->insns;
             fp = newFp;
             self->interpSave.curFrame = fp;
+	            
 #ifdef EASY_GDB
             debugSaveArea = SAVEAREA_FROM_FP(newFp);
 #endif
@@ -2105,6 +2145,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
             self->interpSave.curFrame = newFp;
 
+
             DUMP_REGS(methodToCall, newFp, true);   // show input args
 
             if (self->interpBreak.ctl.subMode != 0) {
@@ -2114,12 +2155,27 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             ILOGD("> native <-- %s.%s %s", methodToCall->clazz->descriptor,
                   methodToCall->name, methodToCall->shorty);
 
+
             /*
              * Jump through native call bridge.  Because we leave no
              * space for locals on native calls, "newFp" points directly
              * to the method arguments.
              */
-            (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+       //     (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+
+	    if(!gDvm.isInstrSetupComplete ||
+			    methodToCall->nativeFunc == dvmResolveNativeMethod ||
+			    methodToCall->nativeFunc == proxyInvoker ||
+			    methodToCall->nativeFunc == proxyConstructor ||
+			    methodToCall->nativeFunc == (DalvikBridgeFunc)dvmAbstractMethodStub ||
+			    methodToCall->nativeFunc == dvmCheckCallJNIMethod ||
+			    methodToCall->nativeFunc == dvmCallJNIMethod ||
+			    !isMethInstrumented(methodToCall)
+			    )
+		    (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+	    else{
+		    jniBoundaryNonBridgeInMagicXZ89(self->instrCount, methodToCall->nativeFunc, newFp, &retval, methodToCall, self);
+	    }
 
             if (self->interpBreak.ctl.subMode != 0) {
                 dvmReportPostNativeInvoke(methodToCall, self, newSaveArea->prevFrame);
@@ -2130,16 +2186,28 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             self->interpSave.curFrame = newSaveArea->prevFrame;
             fp = newSaveArea->prevFrame;
 
+	    bool isExceptionThrown = dvmCheckException(self);
+
+
+	    if(!isExceptionThrown){
+		    LOG_WRITE_RET(methodToCall, retval.j);
+	    }
+	    LOG_METHOD_EXIT_WITH_CHECK((uint32_t)methodToCall);
+	    if(!isExceptionThrown){
+		    LOG_READ_RET(methodToCall, retval.j);
+	    }
+
             /*
              * If the native code threw an exception, or interpreted code
              * invoked by the native call threw one and nobody has cleared
              * it, jump to our local exception handling.
              */
-            if (dvmCheckException(self)) {
+ //           if (dvmCheckException(self)) {
+	    if(isExceptionThrown){
                 ALOGV("Exception thrown by/below native code");
                 GOTO_exceptionThrown();
-            }
-
+             } 
+		
             ILOGD("> retval=0x%llx (leaving native)", retval.j);
             ILOGD("> (return from native %s.%s to %s.%s %s)",
                 methodToCall->clazz->descriptor, methodToCall->name,
diff --git a/vm/mterp/out/InterpC-portable.cpp b/vm/mterp/out/InterpC-portable.cpp
index 0328aa8..8339310 100644
--- a/vm/mterp/out/InterpC-portable.cpp
+++ b/vm/mterp/out/InterpC-portable.cpp
@@ -411,7 +411,71 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
  * "u2 inst".
  */
 # define H(_op)             &&op_##_op
-# define HANDLE_OPCODE(_op) op_##_op:
+# define HANDLE_OPCODE(_op) op_##_op: \
+	if(gDvm.isInstrSetupComplete && !self->isLogDone){\
+		if(gDvm.feature == FEATURE_COUNT){\
+			if(!self->hasStarted){\
+				self->hasStarted = true;\
+				self->startTime = getThreadTime();\
+			}\
+			self->instrCount = safeIncre(self->instrCount);\
+			if(gDvm.isBoundHit){ \
+				u4 ct = getThreadTime();\
+				ALOGD("TIME MODEL. uid: %u, feature: %u, dalvik thread id: %u, posix thread id: %d, instruction count: %u, method count: %u,total time %u",gDvm.targetInstrUID, gDvm.feature, self->threadId, self->systemTid, self->instrCount, self->methodCount, ct - self->startTime);\
+				self->isLogDone = true; \
+			}\
+		}\
+		else if(gDvm.feature == FEATURE_TIME){			      \
+			/*self->instrCount++;*/\
+			if(!self->hasStarted){\
+				self->hasStarted = true;\
+				self->startTime = getThreadTime();\
+			}\
+			self->instrCount = safeIncre(self->instrCount);\
+			if(curMethod !=NULL){\
+				Method* topM = self->topMethod;\
+				if(topM != curMethod){\
+					LOGX("TraceDebug: method entry or return missing in thread %u for instruction %s", self->systemTid, #_op);	\
+					LOGX("TraceDebug: %u currentMethod is %s.%s(%s)",self->systemTid, curMethod->clazz->descriptor,curMethod->name,curMethod->shorty); \
+					if(topM != NULL){\
+					LOGX("TraceDebug: %u topMethod is %s.%s(%s)", self->systemTid, topM->clazz->descriptor,topM->name,topM->shorty);}\
+					else{\
+						LOGX("TraceDebug: topMethod is null");	\
+					}\
+					FIX_STACK(self); \
+				}\
+			}\
+			if(gDvm.isBoundHit){ \
+				updateTotalTime();\
+				u4 ct = getThreadTime();\
+				ALOGD("TIME MODEL. uid: %u, feature: %u, dalvik thread id: %u, posix thread id: %d, instruction count: %u, method count: %u, java time: %u, total time %u", gDvm.targetInstrUID, gDvm.feature, self->threadId, self->systemTid, self->instrCount, self->methodCount, self->interpTotalTime, ct - self->startTime);\
+				self->isLogDone = true; \
+			}\
+		}\
+		else if(gDvm.feature==FEATURE_TRACE || gDvm.feature==FEATURE_TRACE_TIME){\
+			self->instrCount = safeIncre(self->instrCount);\
+			if(curMethod !=NULL){\
+				Method* topM = self->topMethod;\
+				if(topM != curMethod){\
+					LOGX("TraceDebug: method entry or return missing in thread %u for instruction %s", self->systemTid, #_op);	\
+					LOGX("TraceDebug: %u currentMethod is %s.%s(%s)",self->systemTid, curMethod->clazz->descriptor,curMethod->name,curMethod->shorty); \
+					if(topM != NULL){\
+					LOGX("TraceDebug: %u topMethod is %s.%s(%s)", self->systemTid, topM->clazz->descriptor,topM->name,topM->shorty);}\
+					else{\
+						LOGX("TraceDebug: topMethod is null");	\
+					}\
+					FIX_STACK(self); \
+				}\
+			}\
+			\
+		}\
+		else if(gDvm.feature == FEATURE_PIN_TIME){\
+			if(gDvm.isBoundHit){ \
+				self->isLogDone = true; \
+				timeMagicXZ89();\
+			}\
+		}\
+	}
 # define FINISH(_offset) {                                                  \
         ADJUST_PC(_offset);                                                 \
         inst = FETCH(0);                                                    \
@@ -910,7 +974,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;    /* array ptr */                        \
         vsrc2 = arrayInfo >> 8;      /* index */                            \
         ILOGV("|aget%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -921,6 +988,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)]);      \
         ILOGV("+ AGET[%d]=%#x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));   \
+	LOG_READ(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -935,7 +1003,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;   /* BB: array ptr */                     \
         vsrc2 = arrayInfo >> 8;     /* CC: index */                         \
         ILOGV("|aput%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -946,6 +1017,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)] =          \
             GET_REGISTER##_regsize(vdst);                                   \
+        LOG_WRITE(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -976,7 +1048,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iget%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -989,6 +1062,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             dvmGetField##_ftype(obj, ifield->byteOffset));                  \
         ILOGV("+ IGET '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1001,12 +1075,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iget%s-quick v%d,v%d,field@+%u",                            \
             (_opname), vdst, vsrc1, ref);                                   \
+	u4 objAddr = GET_REGISTER(vsrc1);            \
         obj = (Object*) GET_REGISTER(vsrc1);                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ref,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1020,7 +1096,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iput%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1);  \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1033,6 +1110,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             GET_REGISTER##_regsize(vdst));                                  \
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1045,12 +1123,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iput%s-quick v%d,v%d,field@0x%04x",                         \
             (_opname), vdst, vsrc1, ref);                                   \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ref, obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1062,7 +1142,7 @@ GOTO_TARGET_DECL(exceptionThrown);
  * This is controlled by the JIT_STUB_HACK maco.
  */
 
-#define HANDLE_SGET_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SGET_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1079,13 +1159,15 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         SET_REGISTER##_regsize(vdst, dvmGetStaticField##_ftype(sfield));    \
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_READ(OBJ_STATIC,sfAddr,0, _fsize);\
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1102,9 +1184,11 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         dvmSetStaticField##_ftype(sfield, GET_REGISTER##_regsize(vdst));    \
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_WRITE(OBJ_STATIC,sfAddr,0,_fsize);\
     }                                                                       \
     FINISH(2);
 
@@ -1692,6 +1776,7 @@ HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)
         if (newObj == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newObj);
+//	LOG_ALLOC((u4) newObj, clazz->objectSize);
     }
     FINISH(2);
 OP_END
@@ -1726,9 +1811,12 @@ HANDLE_OPCODE(OP_NEW_ARRAY /*vA, vB, class@CCCC*/)
         assert(dvmIsClassInitialized(arrayClass));
 
         newArray = dvmAllocArrayByClass(arrayClass, length, ALLOC_DONT_TRACK);
+/*	u4 objAddr = (u4)newArray; */
         if (newArray == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newArray);
+/*	u4 objSize = dvmArrayObjectSize(newArray);*/
+/*	LOG_ALLOC(objAddr,objSize); */
     }
     FINISH(2);
 OP_END
@@ -2158,59 +2246,59 @@ HANDLE_IPUT_X(OP_IPUT_SHORT,            "", Int, )
 OP_END
 
 /* File: c/OP_SGET.cpp */
-HANDLE_SGET_X(OP_SGET,                  "", Int, )
+HANDLE_SGET_X(OP_SGET,                  "", Int, 4,)
 OP_END
 
 /* File: c/OP_SGET_WIDE.cpp */
-HANDLE_SGET_X(OP_SGET_WIDE,             "-wide", Long, _WIDE)
+HANDLE_SGET_X(OP_SGET_WIDE,             "-wide", Long, 8, _WIDE)
 OP_END
 
 /* File: c/OP_SGET_OBJECT.cpp */
-HANDLE_SGET_X(OP_SGET_OBJECT,           "-object", Object, _AS_OBJECT)
+HANDLE_SGET_X(OP_SGET_OBJECT,           "-object", Object,4, _AS_OBJECT)
 OP_END
 
 /* File: c/OP_SGET_BOOLEAN.cpp */
-HANDLE_SGET_X(OP_SGET_BOOLEAN,          "", Int, )
+HANDLE_SGET_X(OP_SGET_BOOLEAN,          "", Int,1, )
 OP_END
 
 /* File: c/OP_SGET_BYTE.cpp */
-HANDLE_SGET_X(OP_SGET_BYTE,             "", Int, )
+HANDLE_SGET_X(OP_SGET_BYTE,             "", Int, 1,)
 OP_END
 
 /* File: c/OP_SGET_CHAR.cpp */
-HANDLE_SGET_X(OP_SGET_CHAR,             "", Int, )
+HANDLE_SGET_X(OP_SGET_CHAR,             "", Int, 2,)
 OP_END
 
 /* File: c/OP_SGET_SHORT.cpp */
-HANDLE_SGET_X(OP_SGET_SHORT,            "", Int, )
+HANDLE_SGET_X(OP_SGET_SHORT,            "", Int,2, )
 OP_END
 
 /* File: c/OP_SPUT.cpp */
-HANDLE_SPUT_X(OP_SPUT,                  "", Int, )
+HANDLE_SPUT_X(OP_SPUT,                  "", Int, 4, )
 OP_END
 
 /* File: c/OP_SPUT_WIDE.cpp */
-HANDLE_SPUT_X(OP_SPUT_WIDE,             "-wide", Long, _WIDE)
+HANDLE_SPUT_X(OP_SPUT_WIDE,             "-wide", Long, 8, _WIDE)
 OP_END
 
 /* File: c/OP_SPUT_OBJECT.cpp */
-HANDLE_SPUT_X(OP_SPUT_OBJECT,           "-object", Object, _AS_OBJECT)
+HANDLE_SPUT_X(OP_SPUT_OBJECT,           "-object", Object, 4, _AS_OBJECT)
 OP_END
 
 /* File: c/OP_SPUT_BOOLEAN.cpp */
-HANDLE_SPUT_X(OP_SPUT_BOOLEAN,          "", Int, )
+HANDLE_SPUT_X(OP_SPUT_BOOLEAN,          "", Int,1, )
 OP_END
 
 /* File: c/OP_SPUT_BYTE.cpp */
-HANDLE_SPUT_X(OP_SPUT_BYTE,             "", Int, )
+HANDLE_SPUT_X(OP_SPUT_BYTE,             "", Int, 1, )
 OP_END
 
 /* File: c/OP_SPUT_CHAR.cpp */
-HANDLE_SPUT_X(OP_SPUT_CHAR,             "", Int, )
+HANDLE_SPUT_X(OP_SPUT_CHAR,             "", Int, 2, )
 OP_END
 
 /* File: c/OP_SPUT_SHORT.cpp */
-HANDLE_SPUT_X(OP_SPUT_SHORT,            "", Int, )
+HANDLE_SPUT_X(OP_SPUT_SHORT,            "", Int, 2, )
 OP_END
 
 /* File: c/OP_INVOKE_VIRTUAL.cpp */
@@ -2756,11 +2844,11 @@ HANDLE_IPUT_X(OP_IPUT_VOLATILE,         "-volatile", IntVolatile, )
 OP_END
 
 /* File: c/OP_SGET_VOLATILE.cpp */
-HANDLE_SGET_X(OP_SGET_VOLATILE,         "-volatile", IntVolatile, )
+HANDLE_SGET_X(OP_SGET_VOLATILE,         "-volatile", IntVolatile, 4,)
 OP_END
 
 /* File: c/OP_SPUT_VOLATILE.cpp */
-HANDLE_SPUT_X(OP_SPUT_VOLATILE,         "-volatile", IntVolatile, )
+HANDLE_SPUT_X(OP_SPUT_VOLATILE,         "-volatile", IntVolatile, 4, )
 OP_END
 
 /* File: c/OP_IGET_OBJECT_VOLATILE.cpp */
@@ -2776,11 +2864,11 @@ HANDLE_IPUT_X(OP_IPUT_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, _WIDE)
 OP_END
 
 /* File: c/OP_SGET_WIDE_VOLATILE.cpp */
-HANDLE_SGET_X(OP_SGET_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, _WIDE)
+HANDLE_SGET_X(OP_SGET_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, 8, _WIDE)
 OP_END
 
 /* File: c/OP_SPUT_WIDE_VOLATILE.cpp */
-HANDLE_SPUT_X(OP_SPUT_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, _WIDE)
+HANDLE_SPUT_X(OP_SPUT_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, 8, _WIDE)
 OP_END
 
 /* File: c/OP_BREAKPOINT.cpp */
@@ -3014,11 +3102,11 @@ HANDLE_IPUT_X(OP_IPUT_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, _AS_
 OP_END
 
 /* File: c/OP_SGET_OBJECT_VOLATILE.cpp */
-HANDLE_SGET_X(OP_SGET_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, _AS_OBJECT)
+HANDLE_SGET_X(OP_SGET_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, 4, _AS_OBJECT)
 OP_END
 
 /* File: c/OP_SPUT_OBJECT_VOLATILE.cpp */
-HANDLE_SPUT_X(OP_SPUT_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, _AS_OBJECT)
+HANDLE_SPUT_X(OP_SPUT_OBJECT_VOLATILE,  "-object-volatile", ObjectVolatile, 4, _AS_OBJECT)
 OP_END
 
 /* File: c/OP_UNUSED_FF.cpp */
@@ -3599,12 +3687,19 @@ GOTO_TARGET(returnFromMethod)
             GOTO_bail();
         }
 
+	uint32_t maddr = (uint32_t)curMethod;
+
         /* update thread FP, and reset local variables */
         self->interpSave.curFrame = fp;
         curMethod = SAVEAREA_FROM_FP(fp)->method;
         self->interpSave.method = curMethod;
-        //methodClass = curMethod->clazz;
+	//methodClass = curMethod->clazz;
         methodClassDex = curMethod->clazz->pDvmDex;
+
+	LOG_WRITE_RET(curMethod, retval.j);
+	LOG_METHOD_EXIT_WITH_CHECK(maddr);
+	LOG_READ_RET(curMethod, retval.j);
+
         pc = saveArea->savedPc;
         ILOGD("> (return to %s.%s %s)", curMethod->clazz->descriptor,
             curMethod->name, curMethod->shorty);
@@ -3799,8 +3894,12 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
         //printf(" --> %s.%s %s\n", methodToCall->clazz->descriptor,
         //    methodToCall->name, methodToCall->shorty);
 
+//	LOG_METHOD_ENTRANCE((uint32_t)methodToCall, methodToCall->clazz->descriptor, methodToCall->name,
+//			    methodToCall->shorty,dvmIsNativeMethod(methodToCall));
+	
         u4* outs;
         int i;
+	u4 argc;
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -3810,6 +3909,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             // so few args it won't matter much
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
+	    argc = vsrc1;
             outs = OUTS_FROM_FP(fp, vsrc1);
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
@@ -3821,6 +3921,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(count <= 5);
 
             outs = OUTS_FROM_FP(fp, count);
+	    argc = count;
 #if 0
             if (count == 5) {
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -3850,6 +3951,12 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             }
 #endif
         }
+	{
+		LOG_WRITE_PARAM(methodToCall, outs, argc);
+		LOG_METHOD_ENTRANCE((uint32_t)methodToCall, methodToCall->clazz->descriptor, methodToCall->name,
+				methodToCall->shorty,dvmIsNativeMethod(methodToCall));
+		LOG_READ_PARAM(methodToCall,outs,argc);
+	}
     }
 
     /*
@@ -3934,6 +4041,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             pc = methodToCall->insns;
             fp = newFp;
             self->interpSave.curFrame = fp;
+	            
 #ifdef EASY_GDB
             debugSaveArea = SAVEAREA_FROM_FP(newFp);
 #endif
@@ -3948,6 +4056,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
             self->interpSave.curFrame = newFp;
 
+
             DUMP_REGS(methodToCall, newFp, true);   // show input args
 
             if (self->interpBreak.ctl.subMode != 0) {
@@ -3957,12 +4066,27 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             ILOGD("> native <-- %s.%s %s", methodToCall->clazz->descriptor,
                   methodToCall->name, methodToCall->shorty);
 
+
             /*
              * Jump through native call bridge.  Because we leave no
              * space for locals on native calls, "newFp" points directly
              * to the method arguments.
              */
-            (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+       //     (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+
+	    if(!gDvm.isInstrSetupComplete ||
+			    methodToCall->nativeFunc == dvmResolveNativeMethod ||
+			    methodToCall->nativeFunc == proxyInvoker ||
+			    methodToCall->nativeFunc == proxyConstructor ||
+			    methodToCall->nativeFunc == (DalvikBridgeFunc)dvmAbstractMethodStub ||
+			    methodToCall->nativeFunc == dvmCheckCallJNIMethod ||
+			    methodToCall->nativeFunc == dvmCallJNIMethod ||
+			    !isMethInstrumented(methodToCall)
+			    )
+		    (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+	    else{
+		    jniBoundaryNonBridgeInMagicXZ89(self->instrCount, methodToCall->nativeFunc, newFp, &retval, methodToCall, self);
+	    }
 
             if (self->interpBreak.ctl.subMode != 0) {
                 dvmReportPostNativeInvoke(methodToCall, self, newSaveArea->prevFrame);
@@ -3973,16 +4097,28 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             self->interpSave.curFrame = newSaveArea->prevFrame;
             fp = newSaveArea->prevFrame;
 
+	    bool isExceptionThrown = dvmCheckException(self);
+
+
+	    if(!isExceptionThrown){
+		    LOG_WRITE_RET(methodToCall, retval.j);
+	    }
+	    LOG_METHOD_EXIT_WITH_CHECK((uint32_t)methodToCall);
+	    if(!isExceptionThrown){
+		    LOG_READ_RET(methodToCall, retval.j);
+	    }
+
             /*
              * If the native code threw an exception, or interpreted code
              * invoked by the native call threw one and nobody has cleared
              * it, jump to our local exception handling.
              */
-            if (dvmCheckException(self)) {
+ //           if (dvmCheckException(self)) {
+	    if(isExceptionThrown){
                 ALOGV("Exception thrown by/below native code");
                 GOTO_exceptionThrown();
-            }
-
+             } 
+		
             ILOGD("> retval=0x%llx (leaving native)", retval.j);
             ILOGD("> (return from native %s.%s to %s.%s %s)",
                 methodToCall->clazz->descriptor, methodToCall->name,
diff --git a/vm/mterp/out/InterpC-x86.cpp b/vm/mterp/out/InterpC-x86.cpp
index 77dc888..c61b3ae 100644
--- a/vm/mterp/out/InterpC-x86.cpp
+++ b/vm/mterp/out/InterpC-x86.cpp
@@ -964,7 +964,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;    /* array ptr */                        \
         vsrc2 = arrayInfo >> 8;      /* index */                            \
         ILOGV("|aget%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -975,6 +978,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)]);      \
         ILOGV("+ AGET[%d]=%#x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));   \
+	LOG_READ(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -989,7 +993,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = arrayInfo & 0xff;   /* BB: array ptr */                     \
         vsrc2 = arrayInfo >> 8;     /* CC: index */                         \
         ILOGV("|aput%s v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);        \
-        arrayObj = (ArrayObject*) GET_REGISTER(vsrc1);                      \
+	u4 objAddr = GET_REGISTER(vsrc1);\
+	u4 arrIdx = GET_REGISTER(vsrc2);\
+        arrayObj = (ArrayObject*) objAddr;                      \
+	u4 objSize = dvmArrayObjectSize(arrayObj);\
         if (!checkForNull((Object*) arrayObj))                              \
             GOTO_exceptionThrown();                                         \
         if (GET_REGISTER(vsrc2) >= arrayObj->length) {                      \
@@ -1000,6 +1007,7 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*)(void*)arrayObj->contents)[GET_REGISTER(vsrc2)] =          \
             GET_REGISTER##_regsize(vdst);                                   \
+        LOG_WRITE(OBJ_ARRAY,objAddr,arrIdx*sizeof(_type),objSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1030,7 +1038,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iget%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1043,6 +1052,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             dvmGetField##_ftype(obj, ifield->byteOffset));                  \
         ILOGV("+ IGET '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1055,12 +1065,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iget%s-quick v%d,v%d,field@+%u",                            \
             (_opname), vdst, vsrc1, ref);                                   \
+	u4 objAddr = GET_REGISTER(vsrc1);            \
         obj = (Object*) GET_REGISTER(vsrc1);                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_READ(OBJ_REF,objAddr,ref,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1074,7 +1086,8 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);   /* object ptr */                            \
         ref = FETCH(1);         /* field ref */                             \
         ILOGV("|iput%s v%d,v%d,field@0x%04x", (_opname), vdst, vsrc1, ref); \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1);  \
+        obj = (Object*) objAddr;                                \
         if (!checkForNull(obj))                                             \
             GOTO_exceptionThrown();                                         \
         ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
@@ -1087,6 +1100,7 @@ GOTO_TARGET_DECL(exceptionThrown);
             GET_REGISTER##_regsize(vdst));                                  \
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->name,                         \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ifield->byteOffset,obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1099,12 +1113,14 @@ GOTO_TARGET_DECL(exceptionThrown);
         ref = FETCH(1);         /* field offset */                          \
         ILOGV("|iput%s-quick v%d,v%d,field@0x%04x",                         \
             (_opname), vdst, vsrc1, ref);                                   \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
+	u4 objAddr = GET_REGISTER(vsrc1); \
+        obj = (Object*) objAddr;                                \
         if (!checkForNullExportPC(obj, fp, pc))                             \
             GOTO_exceptionThrown();                                         \
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+	LOG_WRITE(OBJ_REF,objAddr,ref, obj->clazz->objectSize);\
     }                                                                       \
     FINISH(2);
 
@@ -1116,7 +1132,7 @@ GOTO_TARGET_DECL(exceptionThrown);
  * This is controlled by the JIT_STUB_HACK maco.
  */
 
-#define HANDLE_SGET_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SGET_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1133,13 +1149,15 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         SET_REGISTER##_regsize(vdst, dvmGetStaticField##_ftype(sfield));    \
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_READ(OBJ_STATIC,sfAddr,0, _fsize);\
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _regsize)                   \
+#define HANDLE_SPUT_X(_opcode, _opname, _ftype, _fsize, _regsize)           \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
         StaticField* sfield;                                                \
@@ -1156,9 +1174,11 @@ GOTO_TARGET_DECL(exceptionThrown);
                 JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
             }                                                               \
         }                                                                   \
+	u4 sfAddr = (u4)sfield;\
         dvmSetStaticField##_ftype(sfield, GET_REGISTER##_regsize(vdst));    \
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->name, (u8)GET_REGISTER##_regsize(vdst));                \
+	LOG_WRITE(OBJ_STATIC,sfAddr,0,_fsize);\
     }                                                                       \
     FINISH(2);
 
@@ -1171,11 +1191,11 @@ HANDLE_IPUT_X(OP_IPUT_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, _WIDE)
 OP_END
 
 /* File: c/OP_SGET_WIDE_VOLATILE.cpp */
-HANDLE_SGET_X(OP_SGET_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, _WIDE)
+HANDLE_SGET_X(OP_SGET_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, 8, _WIDE)
 OP_END
 
 /* File: c/OP_SPUT_WIDE_VOLATILE.cpp */
-HANDLE_SPUT_X(OP_SPUT_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, _WIDE)
+HANDLE_SPUT_X(OP_SPUT_WIDE_VOLATILE,    "-wide-volatile", LongVolatile, 8, _WIDE)
 OP_END
 
 /* File: c/OP_EXECUTE_INLINE_RANGE.cpp */
@@ -1832,12 +1852,19 @@ GOTO_TARGET(returnFromMethod)
             GOTO_bail();
         }
 
+	uint32_t maddr = (uint32_t)curMethod;
+
         /* update thread FP, and reset local variables */
         self->interpSave.curFrame = fp;
         curMethod = SAVEAREA_FROM_FP(fp)->method;
         self->interpSave.method = curMethod;
-        //methodClass = curMethod->clazz;
+	//methodClass = curMethod->clazz;
         methodClassDex = curMethod->clazz->pDvmDex;
+
+	LOG_WRITE_RET(curMethod, retval.j);
+	LOG_METHOD_EXIT_WITH_CHECK(maddr);
+	LOG_READ_RET(curMethod, retval.j);
+
         pc = saveArea->savedPc;
         ILOGD("> (return to %s.%s %s)", curMethod->clazz->descriptor,
             curMethod->name, curMethod->shorty);
@@ -2032,8 +2059,12 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
         //printf(" --> %s.%s %s\n", methodToCall->clazz->descriptor,
         //    methodToCall->name, methodToCall->shorty);
 
+//	LOG_METHOD_ENTRANCE((uint32_t)methodToCall, methodToCall->clazz->descriptor, methodToCall->name,
+//			    methodToCall->shorty,dvmIsNativeMethod(methodToCall));
+	
         u4* outs;
         int i;
+	u4 argc;
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -2043,6 +2074,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             // so few args it won't matter much
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
+	    argc = vsrc1;
             outs = OUTS_FROM_FP(fp, vsrc1);
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
@@ -2054,6 +2086,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(count <= 5);
 
             outs = OUTS_FROM_FP(fp, count);
+	    argc = count;
 #if 0
             if (count == 5) {
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -2083,6 +2116,12 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             }
 #endif
         }
+	{
+		LOG_WRITE_PARAM(methodToCall, outs, argc);
+		LOG_METHOD_ENTRANCE((uint32_t)methodToCall, methodToCall->clazz->descriptor, methodToCall->name,
+				methodToCall->shorty,dvmIsNativeMethod(methodToCall));
+		LOG_READ_PARAM(methodToCall,outs,argc);
+	}
     }
 
     /*
@@ -2167,6 +2206,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             pc = methodToCall->insns;
             fp = newFp;
             self->interpSave.curFrame = fp;
+	            
 #ifdef EASY_GDB
             debugSaveArea = SAVEAREA_FROM_FP(newFp);
 #endif
@@ -2181,6 +2221,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
             self->interpSave.curFrame = newFp;
 
+
             DUMP_REGS(methodToCall, newFp, true);   // show input args
 
             if (self->interpBreak.ctl.subMode != 0) {
@@ -2190,12 +2231,27 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             ILOGD("> native <-- %s.%s %s", methodToCall->clazz->descriptor,
                   methodToCall->name, methodToCall->shorty);
 
+
             /*
              * Jump through native call bridge.  Because we leave no
              * space for locals on native calls, "newFp" points directly
              * to the method arguments.
              */
-            (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+       //     (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+
+	    if(!gDvm.isInstrSetupComplete ||
+			    methodToCall->nativeFunc == dvmResolveNativeMethod ||
+			    methodToCall->nativeFunc == proxyInvoker ||
+			    methodToCall->nativeFunc == proxyConstructor ||
+			    methodToCall->nativeFunc == (DalvikBridgeFunc)dvmAbstractMethodStub ||
+			    methodToCall->nativeFunc == dvmCheckCallJNIMethod ||
+			    methodToCall->nativeFunc == dvmCallJNIMethod ||
+			    !isMethInstrumented(methodToCall)
+			    )
+		    (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+	    else{
+		    jniBoundaryNonBridgeInMagicXZ89(self->instrCount, methodToCall->nativeFunc, newFp, &retval, methodToCall, self);
+	    }
 
             if (self->interpBreak.ctl.subMode != 0) {
                 dvmReportPostNativeInvoke(methodToCall, self, newSaveArea->prevFrame);
@@ -2206,16 +2262,28 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             self->interpSave.curFrame = newSaveArea->prevFrame;
             fp = newSaveArea->prevFrame;
 
+	    bool isExceptionThrown = dvmCheckException(self);
+
+
+	    if(!isExceptionThrown){
+		    LOG_WRITE_RET(methodToCall, retval.j);
+	    }
+	    LOG_METHOD_EXIT_WITH_CHECK((uint32_t)methodToCall);
+	    if(!isExceptionThrown){
+		    LOG_READ_RET(methodToCall, retval.j);
+	    }
+
             /*
              * If the native code threw an exception, or interpreted code
              * invoked by the native call threw one and nobody has cleared
              * it, jump to our local exception handling.
              */
-            if (dvmCheckException(self)) {
+ //           if (dvmCheckException(self)) {
+	    if(isExceptionThrown){
                 ALOGV("Exception thrown by/below native code");
                 GOTO_exceptionThrown();
-            }
-
+             } 
+		
             ILOGD("> retval=0x%llx (leaving native)", retval.j);
             ILOGD("> (return from native %s.%s to %s.%s %s)",
                 methodToCall->clazz->descriptor, methodToCall->name,
diff --git a/vm/mterp/portable/stubdefs.cpp b/vm/mterp/portable/stubdefs.cpp
index 015057e..5477364 100644
--- a/vm/mterp/portable/stubdefs.cpp
+++ b/vm/mterp/portable/stubdefs.cpp
@@ -33,7 +33,71 @@
  * "u2 inst".
  */
 # define H(_op)             &&op_##_op
-# define HANDLE_OPCODE(_op) op_##_op:
+# define HANDLE_OPCODE(_op) op_##_op: \
+	if(gDvm.isInstrSetupComplete && !self->isLogDone){\
+		if(gDvm.feature == FEATURE_COUNT){\
+			if(!self->hasStarted){\
+				self->hasStarted = true;\
+				self->startTime = getThreadTime();\
+			}\
+			self->instrCount = safeIncre(self->instrCount);\
+			if(gDvm.isBoundHit){ \
+				u4 ct = getThreadTime();\
+				ALOGD("TIME MODEL. uid: %u, feature: %u, dalvik thread id: %u, posix thread id: %d, instruction count: %u, method count: %u,total time %u",gDvm.targetInstrUID, gDvm.feature, self->threadId, self->systemTid, self->instrCount, self->methodCount, ct - self->startTime);\
+				self->isLogDone = true; \
+			}\
+		}\
+		else if(gDvm.feature == FEATURE_TIME){			      \
+			/*self->instrCount++;*/\
+			if(!self->hasStarted){\
+				self->hasStarted = true;\
+				self->startTime = getThreadTime();\
+			}\
+			self->instrCount = safeIncre(self->instrCount);\
+			if(curMethod !=NULL){\
+				Method* topM = self->topMethod;\
+				if(topM != curMethod){\
+					LOGX("TraceDebug: method entry or return missing in thread %u for instruction %s", self->systemTid, #_op);	\
+					LOGX("TraceDebug: %u currentMethod is %s.%s(%s)",self->systemTid, curMethod->clazz->descriptor,curMethod->name,curMethod->shorty); \
+					if(topM != NULL){\
+					LOGX("TraceDebug: %u topMethod is %s.%s(%s)", self->systemTid, topM->clazz->descriptor,topM->name,topM->shorty);}\
+					else{\
+						LOGX("TraceDebug: topMethod is null");	\
+					}\
+					FIX_STACK(self); \
+				}\
+			}\
+			if(gDvm.isBoundHit){ \
+				updateTotalTime();\
+				u4 ct = getThreadTime();\
+				ALOGD("TIME MODEL. uid: %u, feature: %u, dalvik thread id: %u, posix thread id: %d, instruction count: %u, method count: %u, java time: %u, total time %u", gDvm.targetInstrUID, gDvm.feature, self->threadId, self->systemTid, self->instrCount, self->methodCount, self->interpTotalTime, ct - self->startTime);\
+				self->isLogDone = true; \
+			}\
+		}\
+		else if(gDvm.feature==FEATURE_TRACE || gDvm.feature==FEATURE_TRACE_TIME){\
+			self->instrCount = safeIncre(self->instrCount);\
+			if(curMethod !=NULL){\
+				Method* topM = self->topMethod;\
+				if(topM != curMethod){\
+					LOGX("TraceDebug: method entry or return missing in thread %u for instruction %s", self->systemTid, #_op);	\
+					LOGX("TraceDebug: %u currentMethod is %s.%s(%s)",self->systemTid, curMethod->clazz->descriptor,curMethod->name,curMethod->shorty); \
+					if(topM != NULL){\
+					LOGX("TraceDebug: %u topMethod is %s.%s(%s)", self->systemTid, topM->clazz->descriptor,topM->name,topM->shorty);}\
+					else{\
+						LOGX("TraceDebug: topMethod is null");	\
+					}\
+					FIX_STACK(self); \
+				}\
+			}\
+			\
+		}\
+		else if(gDvm.feature == FEATURE_PIN_TIME){\
+			if(gDvm.isBoundHit){ \
+				self->isLogDone = true; \
+				timeMagicXZ89();\
+			}\
+		}\
+	}
 # define FINISH(_offset) {                                                  \
         ADJUST_PC(_offset);                                                 \
         inst = FETCH(0);                                                    \
diff --git a/vm/native/dalvik_system_Zygote.cpp b/vm/native/dalvik_system_Zygote.cpp
index 70d4fea..5503d68 100644
--- a/vm/native/dalvik_system_Zygote.cpp
+++ b/vm/native/dalvik_system_Zygote.cpp
@@ -38,6 +38,12 @@
 #include <sched.h>
 #include <sys/utsname.h>
 #include <sys/capability.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include <fstream>
 
 #if defined(HAVE_PRCTL)
 # include <sys/prctl.h>
@@ -502,6 +508,7 @@ static bool needsNoRandomizeWorkaround() {
 #endif
 }
 
+
 /*
  * Utility routine to fork zygote and specialize the child process.
  */
@@ -565,6 +572,7 @@ static pid_t forkAndSpecializeCommon(const u4* args, bool isSystemServer)
     setSignalHandler();
 
     dvmDumpLoaderStats("zygote");
+    
     pid = fork();
 
     if (pid == 0) {
@@ -690,10 +698,11 @@ static pid_t forkAndSpecializeCommon(const u4* args, bool isSystemServer)
             ALOGE("error in post-zygote initialization");
             dvmAbort();
         }
+	setupInstrumentation(uid);
     } else if (pid > 0) {
-        /* the parent process */
-        free(seInfo);
-        free(niceName);
+	    /* the parent process */
+	    free(seInfo);
+	    free(niceName);
     }
 
     return pid;
diff --git a/vm/native/java_lang_System.cpp b/vm/native/java_lang_System.cpp
index 29063cd..2f98799 100644
--- a/vm/native/java_lang_System.cpp
+++ b/vm/native/java_lang_System.cpp
@@ -224,6 +224,13 @@ static void Dalvik_java_lang_System_arraycopy(const u4* args, JValue* pResult)
         RETURN_VOID();
     }
 
+    Thread* self = dvmThreadSelf();
+    CHECK_STACK_NATIVE(self);
+    u4 srcAddr = (u4)srcArray;
+    u4 dstAddr = (u4)dstArray;
+    LOG_READ(OBJ_ARRAY_ALL, srcAddr ,0, dvmArrayObjectSize(srcArray));
+    LOG_WRITE(OBJ_ARRAY_ALL, dstAddr, 0, dvmArrayObjectSize(dstArray));
+
     ClassObject* srcClass = srcArray->clazz;
     ClassObject* dstClass = dstArray->clazz;
     char srcType = srcClass->descriptor[1];
diff --git a/vm/oo/Array.cpp b/vm/oo/Array.cpp
index 00ec6d9..90a74de 100644
--- a/vm/oo/Array.cpp
+++ b/vm/oo/Array.cpp
@@ -55,12 +55,26 @@ static ArrayObject* allocArray(ClassObject* arrayClass, size_t length,
                 "%s of length %zd exceeds the VM limit", descriptor.c_str(), length);
         return NULL;
     }
+
+    gDvm.allocSize = totalSize;
+
     ArrayObject* newArray = (ArrayObject*)dvmMalloc(totalSize, allocFlags);
     if (newArray != NULL) {
         DVM_OBJECT_INIT(newArray, arrayClass);
         newArray->length = length;
         dvmTrackAllocation(arrayClass, totalSize);
     }
+
+    /*Xin: Ideally, we shouldn't insert the allocation log
+     * in this file as it might include noise from the jvm.
+     * But it is always safe to include more allocations.*/
+
+    u4 objAddr = (u4)newArray;
+    u4 objSize = dvmArrayObjectSize(newArray);
+    Thread* self = dvmThreadSelf();
+    LOG_ALLOC_MCC(objAddr,objSize);
+
+
     return newArray;
 }
 
@@ -157,6 +171,7 @@ ArrayObject* dvmAllocPrimitiveArray(char type, size_t length, int allocFlags)
 
     newArray = allocArray(arrayClass, length, width, allocFlags);
 
+
     /* the caller must dvmReleaseTrackedAlloc if allocFlags==ALLOC_DEFAULT */
     return newArray;
 }
diff --git a/vm/oo/Resolve.cpp b/vm/oo/Resolve.cpp
index ab3de5b..02f53b2 100644
--- a/vm/oo/Resolve.cpp
+++ b/vm/oo/Resolve.cpp
@@ -72,8 +72,9 @@ ClassObject* dvmResolveClass(const ClassObject* referrer, u4 classIdx,
      * methods.
      */
     resClass = dvmDexGetResolvedClass(pDvmDex, classIdx);
-    if (resClass != NULL)
+    if (resClass != NULL){
         return resClass;
+    }
 
     LOGVV("--- resolving class %u (referrer=%s cl=%p)",
         classIdx, referrer->descriptor, referrer->classLoader);
@@ -158,7 +159,6 @@ ClassObject* dvmResolveClass(const ClassObject* referrer, u4 classIdx,
             dexStringByTypeIdx(pDvmDex->pDexFile, classIdx));
         assert(dvmCheckException(dvmThreadSelf()));
     }
-
     return resClass;
 }
 
@@ -275,7 +275,6 @@ Method* dvmResolveMethod(const ClassObject* referrer, u4 methodIdx,
     } else {
         dvmDexSetResolvedMethod(pDvmDex, methodIdx, resMethod);
     }
-
     return resMethod;
 }
 
diff --git a/vm/reflect/Proxy.cpp b/vm/reflect/Proxy.cpp
index 57d32e7..526778b 100644
--- a/vm/reflect/Proxy.cpp
+++ b/vm/reflect/Proxy.cpp
@@ -39,10 +39,10 @@ static void updateExceptionClassList(const Method* method, PointerSet* throws);
 static void createConstructor(ClassObject* clazz, Method* meth);
 static void createHandlerMethod(ClassObject* clazz, Method* dstMeth,
     const Method* srcMeth);
-static void proxyConstructor(const u4* args, JValue* pResult,
-    const Method* method, Thread* self);
-static void proxyInvoker(const u4* args, JValue* pResult,
-    const Method* method, Thread* self);
+//static void proxyConstructor(const u4* args, JValue* pResult,
+//    const Method* method, Thread* self);
+//static void proxyInvoker(const u4* args, JValue* pResult,
+//    const Method* method, Thread* self);
 static bool mustWrapException(const Method* method, const Object* throwable);
 
 /* private static fields in the Proxy class */
@@ -848,7 +848,7 @@ static ArrayObject* boxMethodArgs(const Method* method, const u4* args)
  * This is the constructor for a generated proxy object.  All we need to
  * do is stuff "handler" into "h".
  */
-static void proxyConstructor(const u4* args, JValue* pResult,
+/*static*/ void proxyConstructor(const u4* args, JValue* pResult,
     const Method* method, Thread* self)
 {
     Object* obj = (Object*) args[0];
@@ -867,7 +867,7 @@ static void proxyConstructor(const u4* args, JValue* pResult,
  * a new Object[] array, make the call, and unbox the return value if
  * necessary.
  */
-static void proxyInvoker(const u4* args, JValue* pResult,
+/*static*/ void proxyInvoker(const u4* args, JValue* pResult,
     const Method* method, Thread* self)
 {
     Object* thisObj = (Object*) args[0];
diff --git a/vm/reflect/Reflect.h b/vm/reflect/Reflect.h
index 21bb08d..65bb107 100644
--- a/vm/reflect/Reflect.h
+++ b/vm/reflect/Reflect.h
@@ -125,6 +125,11 @@ INLINE bool dvmIsReflectionMethod(const Method* method)
 ClassObject* dvmGenerateProxyClass(StringObject* str, ArrayObject* interfaces,
     Object* loader);
 
+void proxyConstructor(const u4* args, JValue* pResult,
+    const Method* method, Thread* self);
+void proxyInvoker(const u4* args, JValue* pResult,
+    const Method* method, Thread* self);
+
 /*
  * Create a new java.lang.reflect.Method object based on "meth".
  */

